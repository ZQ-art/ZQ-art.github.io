<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-学生报名系统SUMMARY" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/07/%E5%AD%A6%E7%94%9F%E6%8A%A5%E5%90%8D%E7%B3%BB%E7%BB%9FSUMMARY/" class="article-date">
  <time datetime="2020-06-07T00:49:51.230Z" itemprop="datePublished">2020-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/07/%E5%AD%A6%E7%94%9F%E6%8A%A5%E5%90%8D%E7%B3%BB%E7%BB%9FSUMMARY/">学生报名系统SUMMARY</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>MongoDB</p>
<p>数据库（Database）</p>
<p>按照数据结构来组织、存储和管理数据的仓库  </p>
<p>-关系型数据库（RDBMS）全都是表</p>
<p>-非关系型数据库（No SQL）</p>
<p>文档数据库MongoDB</p>
</li>
<li><p>JS高级函数</p>
<p>.foreach</p>
<p>用于操作数组，遍历数组，需要一个回调函数，作为参数。</p>
<p>回调函数的形参，依次为，value：遍历的数组内容；</p>
<p>index：对应的数组索引，array：数组本身</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value,index,array</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">  <span class="built_in">console</span>.log(array);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>.find</p>
<p>find()方法返回通过测试（函数内判断）的数组的第一个元素的值</p>
<p>如果没有符合条件的元素，则返回undefined</p>
<p>find()对于空数组，函数是不会执行的</p>
<p>find()并没有改变数组的原始值</p>
<p>array.find(function(currentValue,index,arr),thisValue),其中currentValue为当前项，index为当前索引，arr为当前数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> a = test.find(<span class="function"><span class="params">item</span> =&gt;</span> item &gt;<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = test.find(<span class="function"><span class="params">item</span> =&gt;</span> item == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>.map</p>
<p>map()方法创建一个新数组，其结果是该数组中的每一个元素都调用一个提供的函数后返回的结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>];</span><br><span class="line"><span class="keyword">const</span> map1 = array1.map(<span class="function"><span class="params">x</span>=&gt;</span>x*<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map1);</span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">Array</span>[<span class="number">2</span>,<span class="number">8</span>,<span class="number">18</span>,<span class="number">32</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>];</span><br><span class="line"><span class="keyword">const</span> map1 = array1.map(<span class="function"><span class="params">x</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==<span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> x*<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(map1);</span><br><span class="line">&gt;<span class="built_in">Array</span>[<span class="literal">undefined</span>,<span class="number">8</span>,<span class="literal">undefined</span>,<span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure>

<p>会出现三个undefined的原因：</p>
<p>map()方法创建了一个新数组，但新数组并不是在遍历完array后才被赋值的，而是每遍历一次就得到一个值</p>
<p>修改如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>];</span><br><span class="line"><span class="keyword">const</span> map1 = array1.map(<span class="function"><span class="params">x</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==<span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> x*<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(map1);</span><br><span class="line">&gt;<span class="built_in">Array</span>[<span class="literal">undefined</span>,<span class="number">8</span>,<span class="literal">undefined</span>,<span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>js是按照标准的“栈式操作”访问数组，所有的栈式操作的特点是“后进先出”</p>
<p>1.进栈push()</p>
<p>入栈：在栈顶（数组的尾部）添加指定的元素，并返回新数组的长度</p>
<p>2.出栈pop()</p>
<p>出栈：删除栈顶(数组的尾部)的一个元素，并返回删除的元素</p>
<p>3.其他：</p>
<p>shift()：删除数组头部的第一个元素，并返回删除的元素</p>
<p>unshift()：在数组头部的第一个元素前添加一个元素，并返回新数组的长度</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/07/%E5%AD%A6%E7%94%9F%E6%8A%A5%E5%90%8D%E7%B3%BB%E7%BB%9FSUMMARY/" data-id="ckb4ctn690001okvf7m51axwr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Ajax(二)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/11/Ajax(%E4%BA%8C)/" class="article-date">
  <time datetime="2020-04-11T11:47:33.907Z" itemprop="datePublished">2020-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/11/Ajax(%E4%BA%8C)/">Ajax(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Ajax封装"><a href="#Ajax封装" class="headerlink" title="Ajax封装"></a>Ajax封装</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  		<span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    	<span class="comment">//创建ajax对象</span></span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="comment">//配置ajax对象</span></span><br><span class="line">    xhr.open(options.type,options.url);</span><br><span class="line">    <span class="comment">//发送请求</span></span><br><span class="line">    xhr.send();</span><br><span class="line">    <span class="comment">//监听xhr对象下面的onload事件</span></span><br><span class="line">    <span class="comment">//当xhr对象接收完响应数据后触发</span></span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//console.log(xhr.responseText);</span></span><br><span class="line">      options.success(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">ajax(&#123;</span><br><span class="line">  <span class="comment">//请求方式</span></span><br><span class="line">  type:<span class="string">'get'</span>,</span><br><span class="line">  <span class="comment">//请求地址</span></span><br><span class="line">  url:<span class="string">'http://localhost:3000/first'</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="string">'这里是success函数'</span> + data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Ajax封装-pro"><a href="#Ajax封装-pro" class="headerlink" title="Ajax封装(pro)"></a>Ajax封装(pro)</h1><ul>
<li><p>请求参数要考虑的问题</p>
<p>1.请求参数位置的问题</p>
<p>将请求参数传递到ajax函数内部，在函数内部根据请求方式的不同将请求参数放置在不同的位置</p>
<p>get 放在请求地址的后面</p>
<p>post 放在send方法中</p>
<p>2.请求参数格式的问题</p>
<p>application/x-www-form-urlencoded</p>
<p>​    参数名称=参数值&amp;参数名称=参数值</p>
<p>​    name=zhangsan&amp;age=20</p>
</li>
</ul>
<p>  application/json</p>
<p>  ​    {name：’zhangsan’,age:20}</p>
<ul>
<li>传递对象数据类型对于函数调用者更加友好</li>
<li>在函数内部对象数据类型转换为字符串数据类型更加方便</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  		<span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">  			<span class="comment">//存储的是默认值</span></span><br><span class="line">  			<span class="keyword">var</span> defaults = &#123;</span><br><span class="line">  					type:<span class="string">'get'</span>,</span><br><span class="line">             url:<span class="string">' '</span>,</span><br><span class="line">             data:&#123;&#125;,</span><br><span class="line">             header:&#123;</span><br><span class="line">               <span class="string">'Content-Type'</span>:<span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">             &#125;,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">            error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="comment">//使用options对象中的属性覆盖defaults对象中的属性</span></span><br><span class="line">			<span class="built_in">Object</span>.assign(defaults,options);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    	<span class="comment">//创建ajax对象</span></span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  <span class="comment">//拼接请求参数的变量</span></span><br><span class="line">  <span class="keyword">var</span> params = <span class="string">''</span>;</span><br><span class="line">  <span class="comment">//循环对象，用for in</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> defaults.data)&#123;</span><br><span class="line">    <span class="comment">//将参数转换为字符串格式</span></span><br><span class="line">    params +=attr +<span class="string">'='</span>+ options.data[attr]+<span class="string">'&amp;'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  	&#123;</span></span><br><span class="line"><span class="comment">  			name:'zhangsan',</span></span><br><span class="line"><span class="comment">  			age:20</span></span><br><span class="line"><span class="comment">  	&#125;</span></span><br><span class="line"><span class="comment">  	name=zhangsan&amp;age=20</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//截取掉最后一个'&amp;'</span></span><br><span class="line">  params = params.substr(<span class="number">0</span>,params.length<span class="number">-1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//判断请求方式</span></span><br><span class="line">  <span class="keyword">if</span>(defaults.type ==<span class="string">'get'</span>)&#123;</span><br><span class="line">    defaults.url = defaults.url +<span class="string">'?'</span>+params;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//配置ajax对象</span></span><br><span class="line">    xhr.open(defaults.type,defaults.url);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(defaults.type ==<span class="string">'post'</span>)&#123;</span><br><span class="line">    <span class="comment">//post方法必须设置请求参数格式的类型</span></span><br><span class="line">   <span class="comment">//用户希望的向服务器端传递的请求参数的类型</span></span><br><span class="line">   <span class="keyword">var</span> contentType = defaults.header[<span class="string">'Content-Type'</span>] </span><br><span class="line">   <span class="comment">//设置请求参数的类型</span></span><br><span class="line">   xhr.setRequestHeader(<span class="string">'Content-Type'</span>,contentType);</span><br><span class="line">    <span class="comment">//判断用户希望的请求参数格式的类型</span></span><br><span class="line">    <span class="comment">//如果类型为json</span></span><br><span class="line">    <span class="keyword">if</span>(contentType ==<span class="string">'application/json'</span>)&#123;</span><br><span class="line">      <span class="comment">//向服务器端传递json数据格式的参数</span></span><br><span class="line">      xhr.send(<span class="built_in">JSON</span>.stringfy(defaults.data))</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//向服务器端传递普通类型的请求参数</span></span><br><span class="line">      xhr.send(params);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//发送请求</span></span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//监听xhr对象下面的onload事件</span></span><br><span class="line">    <span class="comment">//当xhr对象接收完响应数据后触发</span></span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//xhr.getResponseHeader()</span></span><br><span class="line">      <span class="comment">//获取响应头中的数据</span></span><br><span class="line">     <span class="keyword">var</span> contentType = xhr.getResponseHeader(<span class="string">'Content-Type'</span>);</span><br><span class="line">      <span class="comment">//服务器端返回的数据</span></span><br><span class="line">      <span class="keyword">var</span> responseText = xhr.responseText;</span><br><span class="line">      <span class="comment">//如果响应类型中包含application/json</span></span><br><span class="line">      <span class="keyword">if</span>(contentType.includes(<span class="string">'application/json'</span>))&#123;</span><br><span class="line">         		<span class="comment">//将json字符串转换为json对象</span></span><br><span class="line">        		responseText = <span class="built_in">JSON</span>.parse(responseText)</span><br><span class="line">         &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//将处理成功的情况和处理失败的情况分离</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//当http状态码等于200的时候</span></span><br><span class="line">      <span class="keyword">if</span>(xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="comment">//请求成功 调用处理成功情况的函数</span></span><br><span class="line">        defaults.success(responseText,xhr);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//请求失败 调用处理失败请况的函数</span></span><br><span class="line">        defaults.error(responseText,xhr);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">ajax(&#123;</span><br><span class="line">  <span class="comment">//请求方式</span></span><br><span class="line">  type:<span class="string">'get'</span>,</span><br><span class="line">  <span class="comment">//请求地址</span></span><br><span class="line">  url:<span class="string">'http://localhost:3000/first'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    	name:<span class="string">'zhangsan'</span>,</span><br><span class="line">    	age:<span class="number">20</span></span><br><span class="line">  &#125;,</span><br><span class="line">  header:&#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>:<span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">    <span class="comment">//或者'Content-Type':'application/x-www-form-urlencoded'</span></span><br><span class="line">  &#125;</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    	<span class="comment">//console.log('这里是success函数' + data)</span></span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="string">'这里是success函数'</span>);</span><br><span class="line">  	<span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;,</span><br><span class="line">	error:<span class="function"><span class="keyword">function</span>(<span class="params">data,xhr</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这里是error函数，'</span>+data);</span><br><span class="line">    <span class="built_in">console</span>.log(xhr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h1><ul>
<li>作用：使用模板引擎提供的模板语法，可以将数据和HTML拼接起来</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/11/Ajax(%E4%BA%8C)/" data-id="ckb4ctn5w0000okvfh3ah1q1g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Ajax(一)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/10/Ajax(%E4%B8%80)/" class="article-date">
  <time datetime="2020-04-10T12:14:45.619Z" itemprop="datePublished">2020-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/10/Ajax(%E4%B8%80)/">Ajax运行原理及实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Ajax运行原理及实现"><a href="#Ajax运行原理及实现" class="headerlink" title="Ajax运行原理及实现"></a>Ajax运行原理及实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type:<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  <span class="comment">//1.创建ajax对象</span></span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"> <span class="comment">//2.告诉ajax对象要向哪发送请求，以什么方式发送请求</span></span><br><span class="line"> <span class="comment">//1）请求方式 2）请求地址</span></span><br><span class="line"> xhr.open(<span class="string">'get'</span>,<span class="string">'http://localhost:3000/first'</span>);</span><br><span class="line"><span class="comment">//3.发送请求</span></span><br><span class="line"> xhr.send();</span><br><span class="line"><span class="comment">//4.获取服务器端响应到客户端的数据</span></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(xhr.responseText)</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建路由</p>
<p>在app.js中</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/first'</span>,(req,res)=&gt;&#123;</span><br><span class="line">  res.send(<span class="string">'Hello Ajax'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>服务器端响应的数据格式</li>
</ul>
<p>​       在真实的项目中，服务器端大多数情况下会以JSON对象作为响应数据的格式。当客户端拿到响应数据时，要将JSON数据和HTML字符串进行拼接，然后将拼接的结果显示在页面中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理服务器端返回的JSON数据</span></span><br><span class="line">&lt;script type:<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  <span class="comment">//1.创建ajax对象</span></span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"> <span class="comment">//2.告诉ajax对象要向哪发送请求，以什么方式发送请求</span></span><br><span class="line"> <span class="comment">//1）请求方式 2）请求地址</span></span><br><span class="line"> xhr.open(<span class="string">'get'</span>,<span class="string">'http://localhost:3000/responseData'</span>);</span><br><span class="line"><span class="comment">//3.发送请求</span></span><br><span class="line"> xhr.send();</span><br><span class="line"><span class="comment">//4.获取服务器端响应到客户端的数据</span></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//可在此处将JSON字符串转换为JSON对象</span></span><br><span class="line">  <span class="built_in">console</span>.log(xhr.responseText)</span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">'&lt;h2&gt;'</span>+ responseText.name +<span class="string">'&lt;/h2&gt;'</span>;<span class="comment">//将JSON对象与HTML进行拼接</span></span><br><span class="line">  <span class="built_in">document</span>.body.innerHTML = str;<span class="comment">//使用DOM方法将拼接好的字符串追加到页面上</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建路由</p>
<p>在app.js中</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'responseData'</span>,(req,res)=&gt;&#123;</span><br><span class="line">   res.send(&#123;<span class="string">"name"</span>:<span class="string">"zs"</span>&#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在http请求与响应的过程中，无论是请求参数还是响应内容，如果是对象类型，最终都会被转换为对象字符串进行传输</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> responseText=<span class="built_in">JSON</span>.parse(xhr.responseText)<span class="comment">//将JSON字符串转换为JSON对象</span></span><br></pre></td></tr></table></figure>

<h1 id="请求参数传递"><a href="#请求参数传递" class="headerlink" title="请求参数传递"></a>请求参数传递</h1><ul>
<li>get请求</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">  		&lt;input type=<span class="string">"text"</span> id=<span class="string">"username"</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;</span></span><br><span class="line"><span class="regexp">  		&lt;input type="text" id="age"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>p&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">  		&lt;input type=<span class="string">"button"</span> value=<span class="string">"提交"</span> id=<span class="string">"btn"</span>&gt;<span class="comment">//实现点击按钮时，获取上面两个文本框的内容</span></span><br><span class="line">  &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">	&lt;script&gt;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/获取按钮元素</span></span><br><span class="line"><span class="regexp">       var btn = document.getElementById('btn');</span></span><br><span class="line"><span class="regexp">			/</span><span class="regexp">/获取姓名文本框</span></span><br><span class="line"><span class="regexp">			var username = decument.getElementById('username');</span></span><br><span class="line"><span class="regexp">			/</span><span class="regexp">/获取年龄文本框</span></span><br><span class="line"><span class="regexp">			var age = decoment.getElementByIl('age');</span></span><br><span class="line"><span class="regexp">			/</span><span class="regexp">/为按钮添加点击事件</span></span><br><span class="line"><span class="regexp">			 btn.onclick = function()&#123;</span></span><br><span class="line"><span class="regexp">         /</span><span class="regexp">/创建Ajax对象</span></span><br><span class="line"><span class="regexp">         var xhr = new XMLHttpRequest();</span></span><br><span class="line"><span class="regexp">         /</span><span class="regexp">/获取用户在文本框中输入的值</span></span><br><span class="line"><span class="regexp">         var nameValue = username.value;</span></span><br><span class="line"><span class="regexp">         var ageValue = age.value;</span></span><br><span class="line"><span class="regexp">         </span></span><br><span class="line"><span class="regexp">         /</span><span class="regexp">/alert(nameValue)</span></span><br><span class="line"><span class="regexp">         </span></span><br><span class="line"><span class="regexp">         /</span><span class="regexp">/拼接：username=123&amp;age=456</span></span><br><span class="line"><span class="regexp">         var params = 'username='+nameValue + '&amp;age=' + ageValue;/</span><span class="regexp">/使用ajax 请求参数需要自己去拼接</span></span><br><span class="line"><span class="regexp">         </span></span><br><span class="line"><span class="regexp">         /</span><span class="regexp">/配置ajax对象</span></span><br><span class="line"><span class="regexp">         /</span><span class="regexp">/将拼接好的请求参数放在请求地址问号的后面xhr.open('get','http:/</span><span class="regexp">/localhost:3000/g</span>et?<span class="string">'+params);</span></span><br><span class="line"><span class="string">         //发送请求</span></span><br><span class="line"><span class="string">         xhr.send();</span></span><br><span class="line"><span class="string">         //获取服务器端响应的数据</span></span><br><span class="line"><span class="string">         xhr.onload = function()&#123;</span></span><br><span class="line"><span class="string">           console.log(xhr.responseText)</span></span><br><span class="line"><span class="string">         &#125;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>服务器端接收参数</p>
<p>在app.js中创建路由</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/get'</span>,(req,res)=&gt;&#123;</span><br><span class="line">   res.send(req.query);<span class="comment">//将接收到的get请求参数响应到浏览器的控制台中</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>post请求如何传递请求参数</li>
</ul>
<p>post请求方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">'content-Type'</span>,<span class="string">'application/x-www-form-urlencoded'</span>)</span><br><span class="line">xhr.send(<span class="string">'name=zhangsan&amp;age=20'</span>);<span class="comment">//将请求参数放在send方法中</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>请求报文</p>
<p>在HTTP请求和响应的过程中传递的数据块就叫报文，包括要传达的数据和一些附加信息，这些数据和信息要遵守规定好的格式</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">  		&lt;input type=<span class="string">"text"</span> id=<span class="string">"username"</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;</span></span><br><span class="line"><span class="regexp">  		&lt;input type="text" id="age"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>p&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">  		&lt;input type=<span class="string">"button"</span> value=<span class="string">"提交"</span> id=<span class="string">"btn"</span>&gt;<span class="comment">//实现点击按钮时，获取上面两个文本框的内容</span></span><br><span class="line">  &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">	&lt;script&gt;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/获取按钮元素</span></span><br><span class="line"><span class="regexp">       var btn = document.getElementById('btn');</span></span><br><span class="line"><span class="regexp">			/</span><span class="regexp">/获取姓名文本框</span></span><br><span class="line"><span class="regexp">			var username = decument.getElementById('username');</span></span><br><span class="line"><span class="regexp">			/</span><span class="regexp">/获取年龄文本框</span></span><br><span class="line"><span class="regexp">			var age = decoment.getElementByIl('age');</span></span><br><span class="line"><span class="regexp">			/</span><span class="regexp">/为按钮添加点击事件</span></span><br><span class="line"><span class="regexp">			 btn.onclick = function()&#123;</span></span><br><span class="line"><span class="regexp">         /</span><span class="regexp">/创建Ajax对象</span></span><br><span class="line"><span class="regexp">         var xhr = new XMLHttpRequest();</span></span><br><span class="line"><span class="regexp">         /</span><span class="regexp">/获取用户在文本框中输入的值</span></span><br><span class="line"><span class="regexp">         var nameValue = username.value;</span></span><br><span class="line"><span class="regexp">         var ageValue = age.value;</span></span><br><span class="line"><span class="regexp">         </span></span><br><span class="line"><span class="regexp">         /</span><span class="regexp">/alert(nameValue)</span></span><br><span class="line"><span class="regexp">         </span></span><br><span class="line"><span class="regexp">         /</span><span class="regexp">/拼接：username=123&amp;age=456</span></span><br><span class="line"><span class="regexp">         var params = 'username='+nameValue + '&amp;age=' + ageValue;/</span><span class="regexp">/使用ajax 请求参数需要自己去拼接</span></span><br><span class="line"><span class="regexp">         </span></span><br><span class="line"><span class="regexp">         /</span><span class="regexp">/配置ajax对象</span></span><br><span class="line"><span class="regexp">        !!! /</span><span class="regexp">/将拼接好的请求参数放在请求地址问号的后面xhr.open('post','http:/</span><span class="regexp">/localhost:3000/</span>post?<span class="string">'+params);</span></span><br><span class="line"><span class="string">         </span></span><br><span class="line"><span class="string">        !!! //设置请求参数格式的类型(post请求必须要设置)(格式对应的固定写法)</span></span><br><span class="line"><span class="string">         xhr.setRequestHeader('</span>content-Type<span class="string">','</span>application/x-www-form-urlencoded<span class="string">');</span></span><br><span class="line"><span class="string">         </span></span><br><span class="line"><span class="string">        !!! //发送请求</span></span><br><span class="line"><span class="string">         xhr.send(params);</span></span><br><span class="line"><span class="string">         //获取服务器端响应的数据</span></span><br><span class="line"><span class="string">         xhr.onload = function()&#123;</span></span><br><span class="line"><span class="string">           console.log(xhr.responseText)</span></span><br><span class="line"><span class="string">         &#125;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建路由(需引入一个第三方模块)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line">app.post(<span class="string">'/post'</span>,(req,res)=&gt;&#123;</span><br><span class="line">  res.send(req.body);<span class="comment">//通过req.body来获取到客户端传递到服务端的post请求参数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="请求参数的格式"><a href="#请求参数的格式" class="headerlink" title="请求参数的格式"></a>请求参数的格式</h1><p>1.application/x-www-form-urlencoded</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=zhangsan&amp;age=<span class="number">20</span>&amp;sex=男</span><br></pre></td></tr></table></figure>

<p>2.application/json</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">name</span>:<span class="string">'zhangsan'</span>,<span class="attr">age</span>:<span class="string">'20'</span>,<span class="attr">sex</span>:<span class="string">'男'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>在请求头中指定Content-Type属性的值是application/json，告诉服务器端当前的请求参数的格式是json。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringfy()<span class="comment">//将json对象转换为json字符串</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type:<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  <span class="comment">//1.创建ajax对象</span></span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"> <span class="comment">//2.告诉ajax对象要向哪发送请求，以什么方式发送请求</span></span><br><span class="line"> <span class="comment">//1）请求方式 2）请求地址</span></span><br><span class="line"> xhr.open(<span class="string">'post'</span>,<span class="string">'http://localhost:3000/json'</span>);</span><br><span class="line"> !!!<span class="comment">//通过请求头告诉服务器端 客户端向服务器端传递的请求参数的格式是什么</span></span><br><span class="line"> xhr.setRequestHeader(<span class="string">'Content-Type'</span>,<span class="string">'application/json'</span>);</span><br><span class="line">!!!<span class="comment">//3.发送请求(必须以字符串的形式进行传递)</span></span><br><span class="line">  <span class="comment">//JSON.stringify()将json对象转换为json字符串</span></span><br><span class="line"> xhr.send(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">name</span>:<span class="string">'lisi'</span>,<span class="attr">age</span>:<span class="number">50</span>&#125;));</span><br><span class="line"><span class="comment">//4.获取服务器端响应到客户端的数据</span></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(xhr.responseText)</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建路由</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用json方法</span></span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.post(<span class="string">'/json'</span>,(req,res)=&gt;&#123;</span><br><span class="line">  res.send(req.body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>注意:get请求是不能提交json对象数据格式的，传统网站的表单提交也是不支持json对象数据格式的</li>
</ul>
<h1 id="获取服务器端的响应"><a href="#获取服务器端的响应" class="headerlink" title="获取服务器端的响应"></a>获取服务器端的响应</h1><ul>
<li><p>Ajax状态码</p>
<p>在创建ajax对象，配置ajax对象，发送请求，以及接受完服务器端响应数据，这个过程中的每一个步骤都会对应一个数值，这个数值就是ajax状态码</p>
<p>0：请求未初始化(还没有调用open())</p>
<p>1:请求已经建立，但是还没有发送(还没有调用send())</p>
<p>2:请求已经发送</p>
<p>3：请求正在处理中，通常响应中已经有部分数据可以用了</p>
<p>4：响应已经完成，可以获取并使用服务器的响应了</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.readyState<span class="comment">//获取Ajax状态码</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>onreadystatechange事件</p>
<p>当Ajax状态码发生变化时将自动触发该事件</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type:<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  	<span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">		<span class="comment">//0 已经创建了ajax对象，但是还没有对Ajax对象进行配置</span></span><br><span class="line">		<span class="built_in">console</span>.log(xhr.readyState);</span><br><span class="line">		xhr.open(<span class="string">'get'</span>,<span class="string">'http://localhost:3000/readystate'</span>);</span><br><span class="line">		<span class="comment">//1 已经对Ajax对象进行配置，但是还没有发送请求</span></span><br><span class="line">		<span class="built_in">console</span>.log(xhr.readyState);</span><br><span class="line">		<span class="comment">//当Ajax状态码发生变化的时候触发</span></span><br><span class="line">		xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//2请求已经发送</span></span><br><span class="line">      <span class="comment">//3已经接收到服务器端的部分数据了</span></span><br><span class="line">      <span class="comment">//4服务器端的响应数据已经接收完成</span></span><br><span class="line">      <span class="built_in">console</span>.log(xhr.readyState);</span><br><span class="line">      <span class="comment">//对ajax状态码进行判断</span></span><br><span class="line">      <span class="comment">//如果状态码的值为4就代表数据已经接收完成了</span></span><br><span class="line">      <span class="keyword">if</span>(xhr.readyState==<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		xhr.send();</span><br><span class="line">		</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建路由</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/readystate'</span>,(req,res)=&gt;&#123;</span><br><span class="line">  res.send(<span class="string">'hello'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Ajax错误处理"><a href="#Ajax错误处理" class="headerlink" title="Ajax错误处理"></a>Ajax错误处理</h1><p><strong>1.网络畅通，服务器端能接收到请求，服务器端返回的结果不是预期结果</strong></p>
<p>​    可以判断服务器端返回的状态码，分别进行处理。xhr.status获取http状态码</p>
<ul>
<li><p>创建路由</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/error'</span>,(req,res)=&gt;&#123;</span><br><span class="line">  res.status(<span class="number">400</span>).send(<span class="string">'not ok'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Ajax错误处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button id=<span class="string">"btn"</span>&gt;发送Ajax请求&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">		&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">      	var btn = document.getElementById('btn');</span></span><br><span class="line"><span class="string">				btn.onclick = function()&#123;</span></span><br><span class="line"><span class="string">            //1.创建ajax对象</span></span><br><span class="line"><span class="string">          var xhr = new XMLHttpRequest();</span></span><br><span class="line"><span class="string">         //2.告诉ajax对象要向哪发送请求，以什么方式发送请求</span></span><br><span class="line"><span class="string">         //1）请求方式 2）请求地址</span></span><br><span class="line"><span class="string">         							      xhr.open('get','http://localhost:3000/error');</span></span><br><span class="line"><span class="string">        //3.发送请求</span></span><br><span class="line"><span class="string">         xhr.send();</span></span><br><span class="line"><span class="string">        //4.获取服务器端响应到客户端的数据</span></span><br><span class="line"><span class="string">        xhr.onload = function ()&#123;</span></span><br><span class="line"><span class="string">         //xhr.status 获取http状态码</span></span><br><span class="line"><span class="string">          console.log(xhr.responseText);</span></span><br><span class="line"><span class="string">          if(xhr.status == 400)&#123;</span></span><br><span class="line"><span class="string">            alert('请求出错');</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        //当网络中断时会触发onerror事件</span></span><br><span class="line"><span class="string">          xhr.onerror = function()&#123;</span></span><br><span class="line"><span class="string">            alert('网络中断，无法发送Ajax请求')</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>2.网络畅通，服务器端没有接收到请求，返回404状态码</strong></p>
<p>检查请求地址是否错误</p>
<p><strong>3.网络畅通，服务器端能接收到请求，服务器端返回500状态码</strong></p>
<p>服务器端错误，找后端程序员进行沟通</p>
<p><strong>4.网络中断，请求无法发送到服务器端</strong></p>
<p>会触发xhr对象下面的onerror事件，在onerror事件处理函数中对错误进行处理</p>
<p>==区分：==</p>
<p>Ajax状态码：表示Ajax请求的过程状态  是ajax对象返回的</p>
<p>Http状态码：表示请求的处理结果  是服务器端返回的</p>
<h1 id="同步异步概述"><a href="#同步异步概述" class="headerlink" title="同步异步概述"></a>同步异步概述</h1><ul>
<li><p>同步</p>
<p>一个人同一时间只能做一件事情，只有一件事情做完，才能做另外一件事情（一行代码执行完毕后才能执行下一行代码，即代码逐行执行）</p>
</li>
<li><p>异步</p>
<p>一个人一件事情做了一半，转而去做其他事情，当其他事情做完以后，再回过头来继续做之前未完成的事情</p>
<p>（落实到代码上，就是异步代码虽然需要花费时间去执行，但程序不会等待异步代码执行完成后再继续执行后续代码，而是直接执行后续代码，当后续代码执行完成后，再回头看异步代码是否返回结果，如果已有返回结果，再调用事先准备好的回调函数处理异步代码执行的结果。）</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">setTimeout(</span><br><span class="line">	()=&gt;&#123;<span class="built_in">console</span>.log(<span class="string">'last'</span>);</span><br><span class="line"> &#125;,<span class="number">2000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/10/Ajax(%E4%B8%80)/" data-id="ck8ve1e7c0000tkvf1xx24ol5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS进阶2.2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/28/JS%E8%BF%9B%E9%98%B62.2/" class="article-date">
  <time datetime="2020-03-28T07:26:48.723Z" itemprop="datePublished">2020-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/28/JS%E8%BF%9B%E9%98%B62.2/">JS进阶2.2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="访问对象的属性和方法"><a href="#访问对象的属性和方法" class="headerlink" title="访问对象的属性和方法"></a>访问对象的属性和方法</h1><h3 id="点运算符（-）"><a href="#点运算符（-）" class="headerlink" title="点运算符（.）"></a>点运算符（.）</h3><p>使用“ . ”来访问对象属性</p>
<p>语法：</p>
<pre><code>objectName.propertyName</code></pre><p>其中，objectName 为对象名称，propertyName为属性名称。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name:<span class="string">'TOM'</span>,</span><br><span class="line">  age:<span class="string">'20'</span>,</span><br><span class="line">  getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中括号运算符（-）"><a href="#中括号运算符（-）" class="headerlink" title="中括号运算符（[]）"></a>中括号运算符（[]）</h3><p>使用“ [ ] ”来访问对象属性</p>
<p>语法：</p>
<pre><code>objectName[propertyName]</code></pre><p>其中，objectName 为对象名称，propertyName为属性名称。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person.name</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">person[<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure>

<p>==最推荐==</p>
<ul>
<li>想要同时访问person的name和age，就将它们定义成一个变量，然后去访问这个变量</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'name'</span>,<span class="string">'age'</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(person[item]);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> creatPerson = <span class="function"><span class="keyword">function</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//声明一个中间对象，该对象就是工厂模式的模子</span></span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="comment">//依次添加我们需要的属性和方法</span></span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建两个实例</span></span><br><span class="line"><span class="keyword">var</span> perTom = createPerson(<span class="string">'TOM'</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> PerJake = createPerson(<span class="string">'Jake'</span>,<span class="number">22</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>用instanceof可以用于识别对象类型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(foo <span class="keyword">instanceof</span> <span class="function"><span class="keyword">function</span>);//<span class="title">true</span></span></span><br></pre></td></tr></table></figure>

<p><strong>如何准确判断一个变量是数组：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span><span class="comment">//true</span></span><br><span class="line"><span class="keyword">typeof</span> arr<span class="comment">//object,typeof是无法判断是否是数组的</span></span><br></pre></td></tr></table></figure>

<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><ul>
<li><p>new关键字的使用:</p>
<p>可以改变this的指向</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">demo();<span class="comment">//window</span></span><br><span class="line"><span class="keyword">new</span> demo();<span class="comment">//demo</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'Ness'</span>,<span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.getName());<span class="comment">//Ness</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>构造函数（扩展）</strong><br>1.var a = {} 其实是 var a = new Object()（a 的构造函数是 Object 函数）</p>
<p>2.var a = [] 其实是 var a = new Array()（a 的构造函数是 Array 函数）</p>
<p>3.function Foo(){…}其实是 var Foo = new Function(…)     （Foo 的构造函数是 Function 函数）</p>
<p>4.使用 instanceof 判断一个函数是否是一个变量的构造函数   (判断一个变量是否为“数组”  变量 instanceof Array)</p>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明构造函数</span></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;<span class="comment">//通过this声明的变量 私有 只能自己用</span></span><br><span class="line">  <span class="keyword">this</span>.age = age;<span class="comment">//私有</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过prototype属性，将方法挂载到原型对象上</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'tim'</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'jak'</span>,<span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.getName === p2.getName);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>既要实现同一个功能，又让每一个实例对象去访问同一个方法</p>
</li>
<li><p>可以让每一个实例对象都通过_proto_来访问到原型对象（爸爸），此时，原型对象中的方法和属性就变成了共有的方法和属性</p>
</li>
<li><p>in 可以用来判断某对象是否拥有这一属性或方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> p1);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3063494184,1372719149&fm=15&gp=0.jpg" alt=""></p>
<p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3667962360,1332879925&fm=15&gp=0.jpg" alt=""></p>
<p>然后实例对象就可以访问原型对象上的方法了</p>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1585394187752&di=951cdb442b702d53536b182db8fce720&imgtype=0&src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fjpg%2F20180111004311454324.jpg" alt=""></p>
<h1 id="更简单的原型写法"><a href="#更简单的原型写法" class="headerlink" title="更简单的原型写法"></a>更简单的原型写法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>:Person,//构造函数 为了严谨需要写</span><br><span class="line">  getName:function()&#123;&#125;,</span><br><span class="line">  getAge:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">  sayHello:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原型规则：</strong></p>
<p> 1.所有的引用类型（数组、对象、函数）都具有对象特性，即可自由扩展属性（除了“null”） </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;obj.a=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> arr =[];arr.a=<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">fn.a=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>2.所有的引用类型（数组、对象、函数）都有一个 <em>proto</em> 属性(隐式原型属性），属性值是一个普通的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj._proto_);</span><br><span class="line"><span class="built_in">console</span>.log(arr._proto_);</span><br><span class="line"><span class="built_in">console</span>.log(fn._proto_);</span><br></pre></td></tr></table></figure>

<p>3.所有的<code>函数</code>，都有一个 prototype(显式原型）属性，属性值也是一个普通的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn._proto_);</span><br></pre></td></tr></table></figure>

<p>4.所有的引用类型（数组、对象、函数）， <em>proto</em> 属性值(隐式原型属性）指向它的==构造函数==的==“prototype”属性值==</p>
<p> 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的<em>proto</em>(即它的构造函数的 prototype（显式原型）)中寻找</p>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><ul>
<li><p>首先明确： ==函数（Function）才有prototype属性，对象（除Object）拥有<strong>proto</strong>。==</p>
</li>
<li><p>所谓原型链，指的就是proto**这一条指针链！</p>
<p>原型链的顶层就是Object.prototype，而这个对象的是没有原型对象的。</p>
</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/787416/201603/787416-20160323103557261-114570044.png" alt=""> </p>
<ul>
<li>_ proto _主要是安放在一个实际的对象中的，一个原型链接，寻找属性方法的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo = &#123;<span class="attr">name</span>:<span class="string">"apple"</span>,<span class="attr">age</span>:<span class="number">20</span>,<span class="attr">sex</span>:<span class="string">'男'</span>&#125;</span><br><span class="line">bar = &#123;<span class="attr">name</span>:<span class="string">"man"</span>&#125;</span><br><span class="line">bar._proto_ =foo</span><br><span class="line">bar.age<span class="comment">//20</span></span><br><span class="line">bar.sex<span class="comment">//'男'</span></span><br></pre></td></tr></table></figure>

<p>_ proto _ 就好比是一个链条，将foo中的属性，挂载到了bar上面</p>
<p>这样就可以在bar中直接用foo中的属性了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a= &#123;</span><br><span class="line">  x:<span class="number">10</span>,</span><br><span class="line">  calculate:<span class="function"><span class="keyword">function</span>(<span class="params">z</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x+<span class="keyword">this</span>.y+z</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b =&#123;</span><br><span class="line">  y:<span class="number">20</span>,</span><br><span class="line">  _proto_:a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c =&#123;</span><br><span class="line">  y:<span class="number">30</span>,</span><br><span class="line">  _proto_:a</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b.calculate(<span class="number">40</span>))<span class="comment">//70</span></span><br><span class="line"><span class="built_in">console</span>.log(c.calculate(<span class="number">50</span>))<span class="comment">//90</span></span><br><span class="line"><span class="comment">/*说明通过_proto_这一链条，即可以继承属性，也可以继承方法*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>prototype是用new来创建一个对象时构造_ proto _用的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.y = y</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.x = <span class="number">100</span></span><br><span class="line">Foo.prototype.calculate = <span class="function"><span class="keyword">function</span>(<span class="params">z</span>)</span>&#123;</span><br><span class="line">  reutrn <span class="keyword">this</span>.x +<span class="keyword">this</span>.y +z</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Foo(<span class="number">20</span>);<span class="comment">//new关键字实例化，就相当于在b上绑定了一个_proto_链条</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Foo(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c.calculate(<span class="number">20</span>))<span class="comment">//150</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b._proto_ === Foo.prototype)<span class="comment">//true</span></span><br><span class="line"><span class="comment">//说明用new关键字实例化之后，b上就有了_proto_这一属性</span></span><br><span class="line"><span class="comment">/*实际上，除了给b绑定了一个_proto_,还绑定了一个constructor（构造函数）*/</span></span><br><span class="line"><span class="built_in">console</span>.log(b.constructor === Foo)<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>prototype就是用于实例化的时候，是用new来创建一个对象时构造_ proto _用的</p>
<p>1）什么是原型链？</p>
<p>  原型链的核心就是依赖对象的_proto_的指向，当自身不存在的属性时，就一层层的扒出创建对象的构造函数，直至到Object时，就没有_proto_指向了。 </p>
<p><img src="https://images2015.cnblogs.com/blog/787416/201603/787416-20160322110905589-2039017350.png" alt=""></p>
<p> 2）如何分析原型链?</p>
<p> 因为_proto_实质找的是prototype，所以我们只要找这个链条上的构造函数的prototype。其中Object.prototype是没有_proto_属性的，它==null。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//p---&gt;Person.prototype ---&gt;Object.prototype---&gt;null</span></span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/1146559/201805/1146559-20180503211106384-1574487392.png" alt=""></p>
<ul>
<li>f.toString(),当这个对象没有这个属性的时候，去它自身的隐式原型中找，==它自身的隐式原型就是它构造函数（Foo）的显式原型==（Foo.prototype）但显式原型（Foo.prototype）中并没有 toString ;但显式原型（Foo.prototype）也是对象，也要在它的隐式原型中找，即在其构造函数 （Object ）的显式原型中去找 toString. 故要在 f.<em>proto</em>(隐式原型）的.<em>proto</em>(隐式原型）中找，如图所示，故输出 null</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/787416/201603/787416-20160323103622089-1134417169.png" alt=""></p>
<p><img src="https://images2015.cnblogs.com/blog/787416/201604/787416-20160402074219504-987295181.png" alt=""></p>
<h1 id="基于原型链的继承"><a href="#基于原型链的继承" class="headerlink" title="基于原型链的继承"></a>基于原型链的继承</h1><ul>
<li><p>JavaScript 只有一种结构：对象。==每个实例对象（ object ）都有一个私有属性（称之为 <strong>proto</strong> ）指向它的构造函数的原型对象（<strong>prototype</strong> ）==。该原型对象也有一个自己的原型对象( <strong>proto</strong> ) ，层层向上直到一个对象的原型对象为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个<strong>原型链</strong>中的最后一个环节。 </p>
</li>
<li><p>继承属性：</p>
<p>JavaScript 对象是动态的属性“包”（指其自己的属性）。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。 </p>
</li>
<li><p>继承方法：</p>
</li>
</ul>
<p>JavaScript 并没有其他基于类的语言所定义的“方法”。在 JavaScript 里，任何函数都可以添加到对象上作为对象的属性。函数的继承与其他的属性继承没有差别，包括上面的“属性遮蔽”（这种情况相当于其他语言的方法重写）。</p>
<p>当继承的函数被调用时，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="noopener">this</a> 指向的是当前继承的对象，而不是继承的函数所在的原型对象。</p>
<ul>
<li>实例:</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/629250/201606/629250-20160614144944276-1223006630.jpg" alt=""></p>
<p> <code>Person</code>是一个函数类型的变量，因此自带了<code>prototype</code>属性，<code>prototype</code>属性中的<code>constructor</code>又指向<code>Person</code>本身；通过<code>new</code>关键字生成的<code>Person</code>类的实例<code>p1</code>，通过<code>__proto__</code>属性指向了<code>Person</code>的原型。这里的<code>__proto__</code>只是为了说明实例<code>p1</code>在内部实现的时候与父类之间存在的关联（指向父类的原型），在实际操作过程中实例可以直接通过<code>.</code>获取父类原型中的属性，从而实现了继承的功能。 </p>
<hr>
<ul>
<li>构造函数 对象 原型链结构图</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/993579/201609/993579-20160906111035879-351015729.png" alt=""></p>
<ul>
<li>{}对象原型链结构图</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/993579/201609/993579-20160906111103519-201088200.png" alt=""></p>
<ul>
<li>[]数组原型链结构图</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/993579/201609/993579-20160906111122348-87163797.png" alt=""></p>
<h1 id="函数的构造函数-Function"><a href="#函数的构造函数-Function" class="headerlink" title="函数的构造函数 Function"></a>函数的构造函数 Function</h1><p>在 js 中 使用 Function 可以实例化函数对象. 也就是说在 js 中函数与普通对象一样, 也是一个对象类型( 非常特殊 )</p>
<ol>
<li>函数是对象, 就可以使用对象的动态特性</li>
<li>函数是对象, 就有构造函数创建函数</li>
<li>函数是函数, 可以创建其他对象(函数的构造函数也是函数)</li>
<li>函数是唯一可以限定变量作用域的结构</li>
</ol>
<p><img src="https://images2015.cnblogs.com/blog/993579/201609/993579-20160906111139629-1979107838.png" alt=""></p>
<h1 id="函数的原型链结构"><a href="#函数的原型链结构" class="headerlink" title="函数的原型链结构"></a>函数的原型链结构</h1><p>任意的一个函数, 都是相当于 Function 的实例. 类似于 {} 与 new Object() 的关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function foo () &#123;&#125;; &#x2F;&#x2F; 告诉解释器, 有一个对象叫 foo, 它是一个函数 &#x2F;&#x2F; 相当于 new Function() 得到一个 函数对象</span><br></pre></td></tr></table></figure>

<ol>
<li>函数有 <code>__proto__</code> 属性</li>
<li>函数的构造函数是 Function</li>
<li>函数应该继承自 <code>Function.prototype</code></li>
<li><code>Fucntion.prototype</code> 继承自 <code>Object.protoype</code></li>
<li>构造函数有prototype, 实例对象才有<strong>proto</strong>指向原型, 构造函数的原型才有 constructor 指向构造函数</li>
</ol>
<p>作用域链是查找一个变量，而原型链是查找一个方法，找它挂载在原型上的方法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/28/JS%E8%BF%9B%E9%98%B62.2/" data-id="ck8bt9k7p0000lgvf9y4698ny" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS进阶2.1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/JS%E8%BF%9B%E9%98%B62.1/" class="article-date">
  <time datetime="2020-03-26T14:44:57.665Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/JS%E8%BF%9B%E9%98%B62.1/">JS进阶2.1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><ul>
<li>对象：特指的某个事物，具有属性和方法（一组无序的属性的集合）</li>
</ul>
<h1 id="JS创建对象的几种方法"><a href="#JS创建对象的几种方法" class="headerlink" title="JS创建对象的几种方法"></a>JS创建对象的几种方法</h1><h3 id="1-通过-创建对象"><a href="#1-通过-创建对象" class="headerlink" title="1.通过{ }创建对象"></a>1.通过{ }创建对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用&#123;&#125;创建对象，等同于new Object();*/</span></span><br><span class="line"><span class="keyword">var</span> o=&#123;&#125;;</span><br><span class="line">o.name = <span class="string">'jack'</span>;</span><br><span class="line">o.age = <span class="number">20</span>;</span><br><span class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">alert(o.name+<span class="string">'-'</span>+o.age);</span><br><span class="line">o.sayName();</span><br></pre></td></tr></table></figure>

<ul>
<li>如果对象不用重复创建，这种方式是比较方便的。 </li>
</ul>
<h3 id="2-通过new-Object-创建对象"><a href="#2-通过new-Object-创建对象" class="headerlink" title="2.通过new Object()创建对象"></a>2.通过new Object()创建对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.name = <span class="string">"zq"</span>;</span><br><span class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);<span class="comment">//此处可以使用this来代指此对象</span></span><br><span class="line">&#125;</span><br><span class="line">o.sayName();</span><br><span class="line">alert(<span class="string">'o instanceof Object&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;'</span>+(o <span class="keyword">instanceof</span> <span class="built_in">Object</span>));<span class="comment">//true</span></span><br><span class="line">alert(<span class="string">"typeof o &gt;&gt;&gt;&gt;&gt;"</span>+<span class="keyword">typeof</span> o);<span class="comment">//object</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实例化一个Object对其添加属性和方法</li>
</ul>
<h3 id="3-通过字面量创建对象"><a href="#3-通过字面量创建对象" class="headerlink" title="3.通过字面量创建对象"></a>3.通过字面量创建对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name:<span class="string">"zq"</span>,</span><br><span class="line">  age:<span class="number">19</span>,</span><br><span class="line">  family:[<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="string">"ccc"</span>],</span><br><span class="line">  say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*对象字面变量是对象定义的一种简写形式*/</span></span><br><span class="line"><span class="keyword">var</span> person =&#123;<span class="attr">name</span>:<span class="string">'yu'</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;<span class="comment">/*是字面量形式*/</span></span><br><span class="line"><span class="comment">/*完全等价于*/</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person.name=<span class="string">'yu'</span>;</span><br><span class="line">person.age=<span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上三种创建对象的方式存在2个问题：</p>
<p> 1.代码冗余； 2.对象中的方法不能共享，每个对象中的方法都是独立的。 </p>
<p>  利用实例化Object或对象字面量很容易创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量重复代码。 为了解决此问题，工厂模式被开发。 </p>
</blockquote>
<hr>
<h3 id="4-使用工厂模式创建对象"><a href="#4-使用工厂模式创建对象" class="headerlink" title="4.使用工厂模式创建对象"></a>4.使用工厂模式创建对象</h3><ul>
<li>这种方式是<code>使用一个函数来创建对象，减少重复代码</code>，解决了前面三种方式的代码冗余的问题，但是方法不能共享的问题还是存在。 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用工厂模式创建对象</span></span><br><span class="line"><span class="comment">//定义一个工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatObject</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o =<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = creatObject(<span class="string">'zq'</span>);</span><br><span class="line"><span class="keyword">var</span> o2 = creatObject(<span class="string">'li'</span>);</span><br><span class="line"><span class="comment">//缺点：调用的还是不同的方法</span></span><br><span class="line"><span class="comment">//优点：解决了前面的代码重复问题</span></span><br><span class="line">alert(o1.sayName===o2.sayName);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>工厂模式解决了重复实例化多个对象的问题，但没有解决对象识别的问题（但是工厂模式却<code>无从识别对象的类型，因为全部都是Object</code>，不像Date、Array等，本例中，得到的都是o对象，对象的类型都是Object，因此出现了构造函数模式）。 </li>
</ul>
<h3 id="5-通过构造函数创建对象"><a href="#5-通过构造函数创建对象" class="headerlink" title="5.通过构造函数创建对象"></a>5.通过构造函数创建对象</h3><ul>
<li>所谓构造函数，也是普通的函数，不过约定俗成，构造函数的名称首字母大写，普通函数的首字母小写。通过<code>new 构造函数</code>来创建对象。 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*构造函数模式创建对象*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'zq'</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'wkx'</span>);</span><br><span class="line">p1.sayName();</span><br><span class="line">p2.sayName();</span><br><span class="line">alert(p1.constructor===p2.constructor);<span class="comment">//true</span></span><br><span class="line">alert(p2.constructor===Person);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">alert(<span class="keyword">typeof</span>(p1));<span class="comment">//object</span></span><br><span class="line"></span><br><span class="line">alert(p1 <span class="keyword">instanceof</span> object);<span class="comment">//true</span></span><br><span class="line">alert(p2 <span class="keyword">instanceof</span> object);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">alert(p1.sayName===p2.sayName);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>内存模型</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1230619-a0025303a4dfd5e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="构造函数模式创建对象"></p>
<ul>
<li>通过内存模型，可以发现，<code>sayName</code>函数是独立存在于每个对象的，所以<code>p1.sayName===p2.sayName</code>结果为<code>false</code>，还是没有解决方法不能共享的问题。 </li>
</ul>
<p><strong>对比工厂模式,构造函数模式有以下不同之处：</strong></p>
<p>1、没有显式地创建对象</p>
<p>2、直接将属性和方法赋给了 this 对象</p>
<p>3、没有 return 语句</p>
<p><strong>以此方法调用构造函数步骤：</strong></p>
<p>1、创建一个新对象</p>
<p>2、将构造函数的作用域赋给新对象（将this指向这个新对象）</p>
<p>3、执行构造函数代码（为这个新对象添加属性）</p>
<p>可以看出，构造函数知道自己从哪里来（通过 instanceof 可以看出其既是Object的实例，又是Person的实例）</p>
<p><strong>使用构造函数主要问题就是</strong>每个方法都要在每个实例上重新创建一遍(==会给每一个实例对象的方法分配空间，虽然方法都是相同的==所以也比较浪费)，前边的person1和person2虽然都有一个sayName的方法，但是那两个方法不是同一个function的实例。alert(person1.sayName == person2.sayName);//false<br>然而，创建两个完全同样任务的Function实例的确没有必要；况且又this对象在，根本不用在执行代码前就把函数绑定到特定对象上面。</p>
<p>因此产生了原型模式</p>
<h3 id="6-通过原型模式创建对象"><a href="#6-通过原型模式创建对象" class="headerlink" title="6.通过原型模式创建对象"></a>6.通过原型模式创建对象</h3><ul>
<li><p><strong>每个方法中都有一个原型（<code>prototype</code>），每个原型都有一个构造器（<code>constructor</code>），构造器又指向这个方法。</strong> </p>
</li>
<li><p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">alert(Animal.prototype.constructor==Animal);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*原型模式创建对象*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Animal.prototype.name = <span class="string">'animal'</span>;</span><br><span class="line">Animal.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="keyword">this</span>.name);&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> Animal();</span><br><span class="line"></span><br><span class="line">a1.sayName();</span><br><span class="line"></span><br><span class="line">alert(a1.sayName === a2.sayName);<span class="comment">//true</span></span><br><span class="line">alert(Animal.prototype.constructor);<span class="comment">//function Animal()&#123;&#125;</span></span><br><span class="line">alert(Animal.prototype.constructor==Animal);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过原型创建对象，把属性和方法绑定到<code>prototype</code>上，通过这种方式创建对象，方法是共享的，<code>每个对象调用的是同一个方法</code>。 </p>
</li>
<li><p>只有用new的函数才有prototype属性<br>    我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。其实prototype是每个构造函数的属性而已。</p>
</li>
<li><p>内存模型</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1230619-67cdeba506bf6105.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="原型模式"></p>
</li>
</ul>
</li>
<li><p>如果往新建的对象中加入属性，那么这个属性是放在对象中，如果存在与原型同名的属性，也不会改变原型的值。但是访问这个属性，拿到的是对象的值。 </p>
</li>
<li><p>==访问的顺序：对象本身&gt;构造函数的prototype==</p>
<p>如果对象中没有该属性，则去访问prototype，如果prototype中没有，继续访问父类，直到Object，如果都没有找到，返回undefined</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*原型模式创建对象*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Animal.prototype.name = <span class="string">'animal'</span>;</span><br><span class="line">Animal.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="keyword">this</span>.name);&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> Animal();</span><br><span class="line"></span><br><span class="line">a1.sayName();</span><br><span class="line"></span><br><span class="line">alert(a1.sayName === a2.sayName);<span class="comment">//true</span></span><br><span class="line">alert(Animal.prototype.constructor);<span class="comment">//function Animal()&#123;&#125;</span></span><br><span class="line"><span class="comment">//修改a2.name,a1的name不会变</span></span><br><span class="line">a2.name =<span class="string">'dog'</span>;</span><br><span class="line">a2.sayName();<span class="comment">//dog</span></span><br><span class="line">a1.sayName();<span class="comment">//animal</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>内存模型</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1230619-3ac4a122c4c50c33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="原型模式"></p>
</li>
<li><p>这种方式创建的对象会存在问题，假如原型中包含有引用类型的属性，那么如果某个对象修改了该属性的值，所有的该原型创建的对象访问的值都会改变。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型模式2</span></span><br><span class="line"><span class="comment">//存在的问题：如果原型中含有引用类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Animal.prototype = &#123;</span><br><span class="line">  name:<span class="string">'animal'</span>,</span><br><span class="line">  friends:[<span class="string">'dog'</span>,<span class="string">'cat'</span>],</span><br><span class="line">  sayName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> Animal();</span><br><span class="line">a2.friends.push(<span class="string">'snake'</span>);</span><br><span class="line">alert(a2.friends);<span class="comment">//[dog,cat,snake]</span></span><br><span class="line">alert(a1.friends);<span class="comment">//[dog,cat,snake]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>内存模型：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1230619-aca37fd2e3e60bc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="原型模式2"></p>
<ul>
<li><strong>原型模式的好处是</strong>所有对象实例共享它的属性和方法（即所谓的共有属性），此外还可以设置实例自己的属性（方法）（即所谓的私有属性），可以覆盖原型对象上的同名属性（方法）。 </li>
<li>原型对象并不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将去的相同的属性值。这还不是最大问题，原型模式的最大问题是由其共享的本性所导致的。 </li>
</ul>
</li>
</ul>
<h3 id="7-通过原型-构造函数的方式创建对象"><a href="#7-通过原型-构造函数的方式创建对象" class="headerlink" title="7.通过原型+构造函数的方式创建对象"></a>7.通过原型+构造函数的方式创建对象</h3><ul>
<li>这种方式结合了上面两种方式，解决了代码冗余，方法不能共享，引用类型改变值的问题。 </li>
<li>构造函数模式用于==定义实例属性==，原型模式用于==定义方法和共享的属性== </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.friends = [<span class="string">'dog'</span>,<span class="string">'cat'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> Aniaml(<span class="string">'d'</span>);</span><br><span class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> Animal(<span class="string">'c'</span>);</span><br><span class="line">a1.friends.push(<span class="string">'snake'</span>);</span><br><span class="line">alert(a1.friends);<span class="comment">//[dog,cat,snake]</span></span><br><span class="line">alert(a2.friends);<span class="comment">//[dog,cat]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>内存模型：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1230619-305e9ce615805671.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="混合模式"></p>
<ul>
<li>混合模式==共享着对相同方法的引用，又保证了每个实例有自己的私有属性==。最大限度的节省了内存。 </li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/26/JS%E8%BF%9B%E9%98%B62.1/" data-id="ck8baf5om0000twvf1rn96z08" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS进阶1.5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/24/JS%E8%BF%9B%E9%98%B61.5/" class="article-date">
  <time datetime="2020-03-24T14:25:56.545Z" itemprop="datePublished">2020-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/24/JS%E8%BF%9B%E9%98%B61.5/">JS进阶1.5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JavaScript中的执行环境、变量环境和词法环境"><a href="#JavaScript中的执行环境、变量环境和词法环境" class="headerlink" title="JavaScript中的执行环境、变量环境和词法环境"></a>JavaScript中的执行环境、变量环境和词法环境</h1><ul>
<li><h5 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h5><blockquote>
<p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。</p>
</blockquote>
<p>执行环境分为：<br> 1）<code>全局执行环境</code>，最外层执行环境，在所有代码未开始执行前就已经创建完毕，页面关闭后销毁。<br> 2）<code>函数执行环境</code>。函数被调用时创建，函数执行完毕后销毁。<br> 3） <code>Eval函数执行环境</code>。</p>
<blockquote>
<p>在第五版中，间接调用 eval 函数会将全局对象作为执行代码的变量环境和词法环境。</p>
</blockquote>
<p>“直接”调用是指<code>函数调用涉及eval标识符</code>，而其他方式都算作间接调用。</p>
</li>
</ul>
<p>  <img src="https:////upload-images.jianshu.io/upload_images/19947844-e67d15d37e4a8f1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/413/format/webp" alt="img"></p>
<p>  ==一个执行环境包括三个组件：this绑定、词法环境组件、变量环境组件。==</p>
  <img src="https:////upload-images.jianshu.io/upload_images/19947844-e94033ec659ac027.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" style="zoom:150%;" />

<ul>
<li><h5 id="词法环境对象"><a href="#词法环境对象" class="headerlink" title="词法环境对象"></a>词法环境对象</h5><p>每个词法环境对象包含两部分：</p>
</li>
<li><p>环境记录器</p>
</li>
<li><p>外部环境的引用（可能为空，比如全局词法环境）</p>
</li>
</ul>
<p>  <strong>环境记录器</strong><br>   环境记录器分为两种：<br>   1）声明式环境记录器<br>   存在于函数作用域中，存储变量、函数、参数。<br>   2）对象式环境记录器<br>   存在于全局作用域和块级作用域中，存储变量、函数。</p>
<p>  <strong>外部环境引用</strong><br>   <code>如果在当前环境内找不到变量，引擎可以通过引用在外部环境继续查找</code>。</p>
<h5 id="变量环境组件与词法环境组件"><a href="#变量环境组件与词法环境组件" class="headerlink" title="变量环境组件与词法环境组件"></a>变量环境组件与词法环境组件</h5><blockquote>
<p>执行环境的词法环境和变量环境组件始终为 词法环境对象。</p>
</blockquote>
<p>  <strong>区别是：</strong><br>   ==let、const声明的变量，外部环境引用保存在词法环境组件中==。<br>   ==var和function声明的变量和保存在环境变量组件中。==</p>
<ul>
<li><p><strong>词法环境</strong>是一个用于定义特定变量和函数标识符在ECMAScript代码的词法嵌套结构上关联关系的规范类型。一个词法环境由一个<strong>环境记录项</strong>和可能为空的<strong>外部词法环境引用</strong>构成。 </p>
</li>
<li><p>Lexical Environments（词法环境）和四个类型的代码结构相对应:</p>
<ul>
<li>Global code:通俗点讲就是源文件代码，就是一个词法环境</li>
<li>==函数代码 ：一个函数块内自己是一个新的词法环境==</li>
<li>eval：进入eval调用的代码有时会创建一个新的词法环境</li>
<li>with结构：一个with结构块内也是自己一个词法环境</li>
<li>catch结构：一个catch结构快内也是自己一个词环境</li>
</ul>
</li>
</ul>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1585070616610&di=bfcafd31e88b7090537d6b2fc5b1144a&imgtype=0&src=http%3A%2F%2Fimg.shangdixinxi.com%2Fup%2Finfo%2F202001%2F20200106205413346203.png" alt="词法环境"></p>
<p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=255426644,1733497759&fm=15&gp=0.jpg" alt="执行上下文"></p>
<h1 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h1><ul>
<li><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3></li>
</ul>
<p>决定了一段代码能够访问到那些数据，这些数据存放在词法环境对象内。</p>
<ul>
<li><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3></li>
</ul>
<p><code>当执行一个函数时</code>，引擎会将函数的执行环境<code>推入执行栈</code>并<code>生成作用域链</code>。</p>
<p> 作用域链是一个==只能单向访问的链表==，这个链表上的每个节点就是<code>执行上下文的变量对象(代码执行时就是活动对象)</code>，单向链表的头部(可被第一个访问的节点)始终都是当前正在被调用执行的函数的变量对象(活动对象)，尾部始终是全局活动对象。 </p>
<p><img src="https://images2015.cnblogs.com/blog/1061765/201703/1061765-20170320120331315-901381700.png" alt="作用域链"></p>
<p>==作用域链的顶部永远是当前环境的词法环境对象，==下一个词法环境对象来自于包含环境，下下个词法环境对象来自于包含环境的包含环境。==作用域链的尾部是全局词法环境对象。==</p>
<p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3723626544,1683564314&fm=26&gp=0.jpg" alt="关于作用域链"></p>
<p>当我们在一个函数内部调用某一个变量时，会从<code>作用域链顶部</code>开始查找。如果在当前执行环境内存在定义则返回，否则会在<code>当前环境的词法环境组件中引用的外部环境引用中</code>查找。然后重复前面的逻辑，==直到找到全局词法环境对象（外部引用环境为null）==如果仍然未找到会抛出异常。</p>
<p><img src="https://img-blog.csdn.net/20160819161953835" alt="某一函数执行时的作用域链"></p>
<ul>
<li><p><strong>作用域链的用途是:</strong></p>
<p><strong>保证对执行环境有权访问的所有变量和函数的==有序==访问。</strong> </p>
</li>
</ul>
<h1 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h1><ul>
<li><p>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</p>
<p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2019533822,4075494923&fm=26&gp=0.jpg" alt="词法作用域"></p>
</li>
</ul>
<h1 id="块级作用域中的变量查找"><a href="#块级作用域中的变量查找" class="headerlink" title="块级作用域中的变量查找"></a>块级作用域中的变量查找</h1><ul>
<li>如果使用了一个在当前作用域中不存在的变量，这时 JavaScript 引擎就需要按照作用域链在其他作用域中查找该变量， </li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/24/JS%E8%BF%9B%E9%98%B61.5/" data-id="ck85ztlht00001kvffqfs42l3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS进阶1.4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/24/JS%E8%BF%9B%E9%98%B61.4/" class="article-date">
  <time datetime="2020-03-24T02:59:38.847Z" itemprop="datePublished">2020-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/24/JS%E8%BF%9B%E9%98%B61.4/">JS进阶1.4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JS中变量的作用域"><a href="#JS中变量的作用域" class="headerlink" title="JS中变量的作用域"></a>JS中变量的作用域</h1><ul>
<li><p>作用域：</p>
<p>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。</p>
</li>
</ul>
<p>1.在js中，变量的定义并<strong>不是以代码块作为作用域</strong>的，而是<strong>以==函数==作为作用域</strong>。也就是说，如果变量是在某个函数中定义的，那么，它在函数以外的地方是不可见的。<code>但是，如果该变量是定义在if或者for这样的代码块中，它在代码块之外是可见的。</code></p>
<p>2.在js中，术语“<strong>全局变量</strong>”指的是==定义在所有函数之外==的变量（也就是定义在全局代码中的变量），与之相对的是“<strong>局部变量</strong>”，所指的是==在某个函数中定义的==变量。其中，<code>函数内的代码可以像访问自己的局部变量那样访问全局变量，反之则不行。</code></p>
<h1 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h1><ul>
<li>JS中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称ES6)中新增了块级作用域。<br>==块作用域由 { } 包括==，if语句和for语句里面的{ }也属于块作用域。 </li>
</ul>
<h1 id="var、let、const的区别"><a href="#var、let、const的区别" class="headerlink" title="var、let、const的区别"></a>var、let、const的区别</h1><ul>
<li><p>变量提升（<strong>Hoisting</strong>），简单定义</p>
<p><strong>变量提升： 在指定作用域里，从代码顺序上看是变量先使用后声明，但运行时变量的 “可访问性” 提升到当前作用域的顶部，其值为 undefined ，没有 “可用性”。</strong></p>
</li>
</ul>
<ol>
<li><p>var定义的变量，没有块的概念，可以跨块访问, ==不能跨函数访问==， 有变量提升。 </p>
</li>
<li><p>let定义的变量，==只能在块作用域里访问==，不能跨块访问，也不能跨函数访问，无变量提升，不可以重复声明。 </p>
<p>在let声明变量前，使用该变量，它是会报错的，而不是像var那样会‘变量提升’。 ES6规定了在let声明变量前不能使用该变量。</p>
<p><strong>注意</strong>：实际上，let是提升了的，只是规定了不能在其声明之前使用而已。这一特性叫“暂时性死区”。且这一特性，仅对遵循‘块级作用域’的命令有效（let、const）。 </p>
</li>
<li><p>const用来定义常量，使用时==必须初始化==(即必须赋值)，==只能在块作用域里访问==，而且==不能修改==， 无变量提升，不可以重复声明。</p>
<p><strong>注意</strong>：const常量，指的是常量对应的内存地址不得改变，而不是对应的值不得改变，所有把应用类型的数据设置为常量，其内部的值是可以改变的，例如：const a={}; a.b=13;//不会报错 const arr=[]; arr.push(123);//不会报错 ； const 与 let 的使用规范一样，与之不同的是：const 声明的是一个常量，且这个常量必须赋值，否则会报错。 </p>
</li>
<li><p>同一个变量只能使用一种方式声明，不然会报错</p>
</li>
</ol>
<h1 id="变量提升所带来的问题"><a href="#变量提升所带来的问题" class="headerlink" title="变量提升所带来的问题"></a>变量提升所带来的问题</h1><h4 id="1-变量容易在不被察觉的情况下被覆盖掉"><a href="#1-变量容易在不被察觉的情况下被覆盖掉" class="headerlink" title="1. 变量容易在不被察觉的情况下被覆盖掉"></a>1. 变量容易在不被察觉的情况下被覆盖掉</h4><h4 id="2-本应销毁的变量没有被销毁"><a href="#2-本应销毁的变量没有被销毁" class="headerlink" title="2. 本应销毁的变量没有被销毁"></a>2. 本应销毁的变量没有被销毁</h4><h1 id="ES6是如何解决变量提升带来的缺陷"><a href="#ES6是如何解决变量提升带来的缺陷" class="headerlink" title="ES6是如何解决变量提升带来的缺陷"></a>ES6是如何解决变量提升带来的缺陷</h1><ul>
<li>ES6引入了let和const关键字，从而使JavaScript也能像其他语言一样拥有了块级作用域</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/24/JS%E8%BF%9B%E9%98%B61.4/" data-id="ck85ztli700011kvf402y3y1p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS进阶1.3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/23/JS%E8%BF%9B%E9%98%B61.3/" class="article-date">
  <time datetime="2020-03-23T10:29:05.442Z" itemprop="datePublished">2020-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/23/JS%E8%BF%9B%E9%98%B61.3/">JS进阶1.3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是JavaScript的调用栈"><a href="#什么是JavaScript的调用栈" class="headerlink" title="什么是JavaScript的调用栈"></a>什么是JavaScript的调用栈</h1><ul>
<li>JavaScript引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript引擎会将执行上下文压入栈中，通常把这种用来<strong>管理执行上下文的栈</strong>称为执行上下文栈，又称==调用栈==。</li>
<li>调用栈就是JS引擎追踪函数执行的一个机制</li>
</ul>
<h1 id="在开发中，如何利用好调用栈"><a href="#在开发中，如何利用好调用栈" class="headerlink" title="在开发中，如何利用好调用栈"></a>在开发中，如何利用好调用栈</h1><ul>
<li><p>如何利用浏览器查看调用栈的信息：</p>
<p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3091621571,2227256708&fm=15&gp=0.jpg" alt="在浏览器中查看调用栈"></p>
</li>
<li><p>使用 consol.trace() 来输出当前的函数调用关系 ：</p>
<p><img src="https://img2018.cnblogs.com/blog/945149/202001/945149-20200103195810005-1761393826.png" alt="trace"></p>
</li>
</ul>
<h1 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h1><img src="http://img3.mukewang.com/5b1278f50001286408000506.jpg" alt="栈溢出" style="zoom:80%;" />

<h3 id="stack-overflow常见解决方法"><a href="#stack-overflow常见解决方法" class="headerlink" title="stack overflow常见解决方法"></a>stack overflow常见解决方法</h3><p>stack overflow一般都是堆栈内存不够<br>1.<strong>递归次数过多</strong><br>解决办法：用==循环==来代替递归一般百分之九十能解决堆栈溢出的问题</p>
<p>2.<strong>创建的局部变量过多</strong><br>解决办法：这种情况一般就是因为局部变量没有及时清除导致的，一般也是递归，要么==把局部变量改成全局变量==，要么==传入引用==（就是再数据类型的前面加以个&amp;，这样不用去重新再子函数里面去开辟一个空间给变量了）要么==用指针==</p>
<p>3.<strong>数组开的过大</strong><br>解决办法：用 ==关键字 new 来动态的分配一个空间给数据==<br>例如： int a = new int[20000]，这样也可以一定程度的解决问题<br>这种方法也可以提高运行速度，但是会牺牲一些内存：</p>
<h3 id="Windows程序的内存机制"><a href="#Windows程序的内存机制" class="headerlink" title="Windows程序的内存机制"></a>Windows程序的内存机制</h3><p>全局变量(局部的静态变量本质也属于此范围)存储于<strong>堆内存,该段内存较大,一般不会溢出</strong>;函数地址、函数参数、局部变量等信息存储于栈内存，<strong>栈内存较小容易发生溢出现象，但是效率高。</strong> </p>
<h3 id="栈溢出的可能原因："><a href="#栈溢出的可能原因：" class="headerlink" title="栈溢出的可能原因："></a><strong>栈溢出的可能原因：</strong></h3><p><strong>1. 函数递归调用层次过深</strong> ，每调用一次，函数的参数、局部变量等信息就压一次栈，并且没有及时出栈。<br><strong>2. 局部变量体积太大</strong> </p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a><strong>解决方案：</strong></h3><p><strong>1.把递归调用函数改用while或者for==循环==来实现</strong> 。<br><strong>2.通过==尾递归优化==</strong>。<br><strong>3.==改用堆内存==</strong>，函数里定义很大的局部变量（例如大数组），这种情况可以将局部变量改为静态变量（实质上也是全局变量）。<br><strong>4.==增大栈的大小值==</strong>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>每调用一个函数。JavaScript引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后JavaScript引擎开始执行函数代码</li>
<li>如果在一个函数A中调用了另一个函数B，那么JavaScript引擎会为B函数创建执行上下文，并将B函数的执行上下文压入栈顶</li>
<li>当前函数执行完毕后，JavaScript引擎会将该函数的执行上下文弹出栈</li>
<li>当分配的调用栈空间被占满时，会引发”堆栈溢出”问题</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/23/JS%E8%BF%9B%E9%98%B61.3/" data-id="ck85a9jih0000f4vfd46fft1d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS进阶1.2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/23/JS%E8%BF%9B%E9%98%B61.2/" class="article-date">
  <time datetime="2020-03-23T01:58:56.660Z" itemprop="datePublished">2020-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/23/JS%E8%BF%9B%E9%98%B61.2/">JS进阶1.2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><ul>
<li><p>可以将“执行上下文”看做当前代码的运行环境或者作用域 </p>
<p>( JS代码被解析和运行时所处的环境，被称之为JavaScript中的执行上下文 )</p>
</li>
</ul>
<img src="https://segmentfault.com/img/remote/1460000008315046" alt="执行上下文" style="zoom:80%;" />

<p>==在执行上下文创建阶段，函数声明与var声明的变量在创建阶段已经被赋予了一个值，var声明被设置为了undefined，函数被设置为了自身函数==，而let const被设置为未初始化 </p>
<ul>
<li><p>JavaScript中的执行上下文分为以下三种类型：全局执行上下文、函数执行上下文、Eval函数执行上下文。 </p>
<ol>
<li><p><strong>全局执行上下文</strong> </p>
<p>在JavaScript中式默认以及最基本的执行上下文，范围很大，类似于全局作用域，当目标代码不在任何函数中的时候，它就位于全局执行上下文中，处于全局执行上下文中的代码做了两件事儿：</p>
<p>1&gt;创建一个全局对象，例如浏览器中的全局对象就是window对象；</p>
<p>2&gt;将this指向这个全局对象，而且需要注意的是：一个程序代码中只存在有且只有一个全局执行上下文；</p>
</li>
<li><p><strong>函数执行上下文</strong> </p>
<p>函数执行上下文，就是处于函数体内的代码解析及运行的环境，当每次调用函数的时候，都会给该函数创建一个函数执行上下文，虽然每个函数都有自己的函数执行上下文，但是只有当函数<code>被调用时</code>该函数执行上下文才会被创建。既然是函数，所以在一个代码程序中可以存在多个函数执行上下文。</p>
</li>
</ol>
</li>
<li><p>当进入每一个函数时，执行该函数就会创建一个函数执行上下文，依次将其推入执行栈的顶部，当<code>函数全部执行完毕</code>，当前函数就开始执行上下文出栈操作，等待垃圾回收</p>
</li>
<li><p>执行上下文栈的特点：</p>
<ol>
<li><p>JS引擎总是从栈顶向下访问</p>
</li>
<li><p>同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待</p>
</li>
<li><p>全局上下文有且仅有一个，并且在<code>浏览器关闭时</code>执行出栈操作</p>
</li>
</ol>
</li>
</ul>
<h1 id="编译器预编译与变量提升"><a href="#编译器预编译与变量提升" class="headerlink" title="编译器预编译与变量提升"></a>编译器预编译与变量提升</h1><ul>
<li><p><strong>编译器解析规则</strong></p>
<p> 编译器运行代码，分为2个阶段，一个预编译阶段，一个是运行阶段 </p>
</li>
<li><p><strong>变量提升</strong></p>
<p>var a = 2这个表达式，实际上javascript将其分为2个声明，var a 和 a = 2；</p>
<p>第一个定义声明在编译阶段，第二个赋值声明在运行阶段；</p>
<p> 这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动” 到了最上面。这个过程就叫作<code>提升</code>。 </p>
</li>
<li><p><strong>函数提升</strong></p>
<p> 函数声明会进行，函数提升，但是函数表达式并不会进行函数提升 </p>
</li>
<li><p>函数优先</p>
<p> 当有变量声明和函数声明的变量名称相同时，根据函数优先原则，函数会覆盖变量； </p>
</li>
</ul>
<img src="https://img-blog.csdnimg.cn/20190925111208117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTg1NTEx,size_16,color_FFFFFF,t_70" alt="此类情况应避免" style="zoom:80%;" />

<ul>
<li><p>summary</p>
<p>1、js代码的运行会分为2个步骤，预编译和运行（执行）阶段，预编译看下面的总结，执行就是从上往下一行一行的运行；</p>
<p>2、找文中的var 和 function；将var的变量和function声明的变量提升到顶部，var的初始化为undefined，function的初始化为函数。</p>
<p>3、var的变量和函数的变量名称相同的时候，根据函数优先的原则，函数会覆盖之前var变量； </p>
<p>4、<strong>var相同的名称，后续声明会忽略；function相同的名称，后续声明会覆盖</strong>；</p>
<p>5、函数定义var foo = function(){} 就当 变量来处理；也就是文中所说的函数声明会提升，但是函数表达式不会提升</p>
</li>
</ul>
<p>==函数声明会整体提升，变量声明仅声明提升（赋值不提升）==</p>
<h1 id="变量对象与预解析"><a href="#变量对象与预解析" class="headerlink" title="变量对象与预解析"></a>变量对象与预解析</h1><p><img src="https://image-static.segmentfault.com/166/721/1667217985-5a168ff4377d9_articlex" alt="执行环境（执行上下文）"></p>
<h3 id="变量对象的创建过程"><a href="#变量对象的创建过程" class="headerlink" title="变量对象的创建过程"></a>变量对象的创建过程</h3><p>1.<strong>建立一个argunments对象</strong>，寻找当前上下文中的参数，并以其参数名以及参数值创建一个属性。</p>
<p>2.<strong>寻找当前上下文当中的function声明</strong>，在变量对象中，以函数名为属性名，创建一个属性，值为函数的引用地址，如果函数名重复的话，后面的引用会覆盖前面的</p>
<p>3.<strong>寻找当前上下文当中的var声明</strong>，在变量对象中，以变量名为其属性名，创建以个属性，值为undefined， <strong>如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。</strong> </p>
<p><img src="https://image-static.segmentfault.com/375/950/37595014-5a16900337e4f_articlex" alt="变量对象的创建过程"></p>
<p>==function声明会比var声明优先级更高一点==</p>
<ul>
<li>变量对象实例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(foo());</span><br><span class="line">  <span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>当执行到test()时会生成执行环境 testEC ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建过程</span></span><br><span class="line">testEC=&#123;</span><br><span class="line">  <span class="comment">//变量对象（variable object）</span></span><br><span class="line">  VO:&#123;&#125;,</span><br><span class="line">  <span class="comment">//作用域链</span></span><br><span class="line">  scopeChain：[],</span><br><span class="line">  <span class="comment">//this指向</span></span><br><span class="line">  <span class="keyword">this</span>：&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对变量对象展开：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">VO=&#123;</span><br><span class="line">  <span class="comment">//传参对象</span></span><br><span class="line">  <span class="built_in">arguments</span>：&#123;&#125;,</span><br><span class="line">  <span class="comment">//在testEC中定义的function</span></span><br><span class="line">  foo:<span class="string">"&lt;foo reference&gt;"</span>,</span><br><span class="line">  <span class="comment">//在testEC中定义的var</span></span><br><span class="line">  a:<span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作</strong> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行阶段</span></span><br><span class="line">VO-&gt;AO<span class="comment">//Active Object</span></span><br><span class="line">AO=&#123;</span><br><span class="line">  <span class="built_in">arguments</span>:&#123;...&#125;,</span><br><span class="line">  foo:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">2</span>&#125;,</span><br><span class="line">  a:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 最后我们将变量对象创建时的VO和执行阶段的AO整合到一起就可以得到整个执行环境中代码的执行顺序： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span>  <span class="title">foo</span>(<span class="params"></span>)//函数声明整体提升</span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line">  <span class="keyword">var</span> a;<span class="comment">//变量声明仅声明提升</span></span><br><span class="line">  <span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(foo());<span class="comment">//2</span></span><br><span class="line">  a=<span class="number">1</span>;<span class="comment">//赋值不提升</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代码中出现相同的变量或者函数怎么办"><a href="#代码中出现相同的变量或者函数怎么办" class="headerlink" title="代码中出现相同的变量或者函数怎么办"></a>代码中出现相同的变量或者函数怎么办</h1><ul>
<li>实例：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showname</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"SIPC"</span>);</span><br><span class="line">&#125;</span><br><span class="line">showname();<span class="comment">//115</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showname</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"115"</span>);</span><br><span class="line">&#125;</span><br><span class="line">showname();<span class="comment">//115</span></span><br></pre></td></tr></table></figure>

<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p><strong>编译时：</strong></p>
<ul>
<li>遇到第一个showname函数，会将其函数体存放到变量环境中</li>
<li>then 遇到第二个showname函数，会继续存放，但<code>2会将1覆盖掉</code></li>
<li>end 变量环境中就只存在第二个showname函数</li>
</ul>
<p><strong>执行时</strong>：</p>
<ul>
<li>由于是从变量环境中查找的showname函数，而变量环境中只保存了第二个showname函数，所以最终，两次调用的都是第二个showname函数的函数体，都打印出115</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>JavaScript代码执行过程中，需要先做变量提升，而之所以需要实现变量提升，是因为JavaScript代码在执行之前需要先编译。在编译阶段，变量和函数会<strong>被存放到变量环境中</strong>，变量的默认值会被设置为undefined；</li>
<li>在代码执行阶段，JavaScript引擎会从<strong>变量环境中</strong>去查找自定义的变量和函数。</li>
<li>如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，这是因为后定义的会<strong>覆盖掉</strong>之前定义的。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/23/JS%E8%BF%9B%E9%98%B61.2/" data-id="ck84bqon50000pgvfdhesdyqp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS进阶1.1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/22/JS%E8%BF%9B%E9%98%B61.1/" class="article-date">
  <time datetime="2020-03-22T15:10:00.570Z" itemprop="datePublished">2020-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/22/JS%E8%BF%9B%E9%98%B61.1/">JS进阶1.1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##JS进阶1.1<br>###数据是如何存储的？</p>
<ul>
<li><strong>基本数据结构</strong>：</li>
</ul>
<p>1.栈：先进后出，后进先出，存一些基本数据类型（即简单的数据段）和引用数据类型的地址<br><img src="http://images.cnitblog.com/i/627148/201405/021619565332359.png" alt="栈"><br>2.堆：无序储存，随用随取（可以通过引用直接获取）的一个空间（不关注存放的顺序，需通过栈内存中存放的地址来访问堆内存中对应的值），空间比较大，存储一些引用数据类型（占据空间大，大小不固定）<br><img src="https://bkimg.cdn.bcebos.com/pic/574e9258d109b3de15adc33ec7bf6c81800a4c51?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U5Mg==,xp_5,yp_5" alt="堆"><br><font color="grey" size="2">堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。</font><br><img src="https://img-blog.csdn.net/20180109104006090?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm1pbmVt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="栈与堆"><br>#####复制<br>######基本数据类型<br>对于基本数据类型，如果进行复制，系统会自动为新的变量在栈内存中分配一个新值</p>
<p>######引用数据类型<br>如果对于数组、对象这样的引用数据类型而言，<br>系统也会自动为新的变量在栈内存中分配一个值，但这个值仅仅是一个地址。<br>也就是说，复制出来的变量和原有的变量具有相同的地址值，指向堆内存中的同一个对象。<br><img src="https://img-blog.csdn.net/20180109104235195?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm1pbmVt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="关于复制"><br><font color="grey" size="2">当修改 obj 或 objCopy 时，都会引起另一个变量的改变。</font><br>3.队列:先进先出<br><img src="http://aliyunzixunbucket.oss-cn-beijing.aliyuncs.com/jpg/06735aeceb8425df63025f26921094ec.jpg?x-oss-process=image/resize,p_100/auto-orient,1/quality,q_90/format,jpg/watermark,image_eXVuY2VzaGk=,t_100" alt="队列"></p>
<ul>
<li><strong>内存空间</strong></li>
</ul>
<p>1.代码空间<br>2.栈空间<br>3.堆空间</p>
<ul>
<li><strong>基本数据类型</strong>:</li>
</ul>
<p>1.Boolean:只有true和false两个值<br>2.Null：只有一个值null<br>3.Undefined：一个没有被赋值的变量默认值为undefined，变量提升时的默认值也是undefined<br>4.Number<br>5.BigInt：可以用任意精度表示整数<br>6.String<br>7.Symbol：符号类型唯一的并且是不可修改的，通常用来作Object的key</p>
<ul>
<li><strong>引用数据类型</strong></li>
</ul>
<p>1.Array<br>2.Object</p>
<p>###静态语言、动态语言、强类型语言、弱类型语言</p>
<ul>
<li><strong>静态语言</strong>：<br><strong>编译时</strong>变量的数据类型即可确定，多数静态语言要求在使用变量之前必须声明数据类型<br>变量若不经强制转换，则永远是该指定的数据类型<br>结构规范，便于调试，较安全，严谨</li>
<li><strong>强类型语言</strong>：不支持隐式类型转换</li>
<li><strong>动态语言</strong>：<br><strong>运行时</strong>确定数据类型，变量的类型是被赋值的那个值的类型，使用之前不需要类型声明<br>一个变量可以赋不同数据类型的值，一个变量的类型是由其应用上下文确定的<br>数据类型可以被忽略，速度快</li>
<li><strong>弱类型语言</strong>：支持隐式类型转换<br><font color="grey">JavaScript是一种动态弱类型语言</font></li>
</ul>
<p>###js中的隐式类型转换<br>Javascript 中，数字 0 为假，非0 均为真</p>
<p>####在条件判断运算 == 中的转换规则是这样的:</p>
<ul>
<li><p>如果比较的两者中有布尔值(Boolean)，会把 Boolean 先转换为对应的 Number，即 0 和 1，然后进行比较。</p>
</li>
<li><p>如果比较的双方中有一方为 Number，一方为 String时，会把 String 通过 Number() 方法转换为数字，然后进行比较。</p>
</li>
<li><p>如果比较的双方中有一方为 Boolean，一方为 String时，则会将<strong>空字符串</strong>“”转换为 false，除此外的一切字符串转换为 true，然后进行比较。</p>
</li>
<li><p>如果比较的双方中有一方为 Number，一方为Object时，则会调用 <strong>valueOf 方法</strong>将Object转换为数字，然后进行比较。</p>
<p>建议在所有使用<strong>条件判断</strong>的时候都使用<strong>全等运算符 ===</strong> 来进行条件判断。全等运算符会先进行数据类型判断，并且<strong>不会发生隐式类型转换</strong>。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/22/JS%E8%BF%9B%E9%98%B61.1/" data-id="ck836lj1b00007kvfbmfg0dh0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/07/%E5%AD%A6%E7%94%9F%E6%8A%A5%E5%90%8D%E7%B3%BB%E7%BB%9FSUMMARY/">学生报名系统SUMMARY</a>
          </li>
        
          <li>
            <a href="/2020/04/11/Ajax(%E4%BA%8C)/">Ajax(二)</a>
          </li>
        
          <li>
            <a href="/2020/04/10/Ajax(%E4%B8%80)/">Ajax运行原理及实现</a>
          </li>
        
          <li>
            <a href="/2020/03/28/JS%E8%BF%9B%E9%98%B62.2/">JS进阶2.2</a>
          </li>
        
          <li>
            <a href="/2020/03/26/JS%E8%BF%9B%E9%98%B62.1/">JS进阶2.1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>