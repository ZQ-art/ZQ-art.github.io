<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JS进阶1.5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/24/JS%E8%BF%9B%E9%98%B61.5/" class="article-date">
  <time datetime="2020-03-24T14:25:56.545Z" itemprop="datePublished">2020-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/24/JS%E8%BF%9B%E9%98%B61.5/">JS进阶1.5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JavaScript中的执行环境、变量环境和词法环境"><a href="#JavaScript中的执行环境、变量环境和词法环境" class="headerlink" title="JavaScript中的执行环境、变量环境和词法环境"></a>JavaScript中的执行环境、变量环境和词法环境</h1><ul>
<li><h5 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h5><blockquote>
<p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。</p>
</blockquote>
<p>执行环境分为：<br> 1）<code>全局执行环境</code>，最外层执行环境，在所有代码未开始执行前就已经创建完毕，页面关闭后销毁。<br> 2）<code>函数执行环境</code>。函数被调用时创建，函数执行完毕后销毁。<br> 3） <code>Eval函数执行环境</code>。</p>
<blockquote>
<p>在第五版中，间接调用 eval 函数会将全局对象作为执行代码的变量环境和词法环境。</p>
</blockquote>
<p>“直接”调用是指<code>函数调用涉及eval标识符</code>，而其他方式都算作间接调用。</p>
</li>
</ul>
<p>  <img src="https:////upload-images.jianshu.io/upload_images/19947844-e67d15d37e4a8f1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/413/format/webp" alt="img"></p>
<p>  ==一个执行环境包括三个组件：this绑定、词法环境组件、变量环境组件。==</p>
  <img src="https:////upload-images.jianshu.io/upload_images/19947844-e94033ec659ac027.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" style="zoom:150%;" />

<ul>
<li><h5 id="词法环境对象"><a href="#词法环境对象" class="headerlink" title="词法环境对象"></a>词法环境对象</h5><p>每个词法环境对象包含两部分：</p>
</li>
<li><p>环境记录器</p>
</li>
<li><p>外部环境的引用（可能为空，比如全局词法环境）</p>
</li>
</ul>
<p>  <strong>环境记录器</strong><br>   环境记录器分为两种：<br>   1）声明式环境记录器<br>   存在于函数作用域中，存储变量、函数、参数。<br>   2）对象式环境记录器<br>   存在于全局作用域和块级作用域中，存储变量、函数。</p>
<p>  <strong>外部环境引用</strong><br>   <code>如果在当前环境内找不到变量，引擎可以通过引用在外部环境继续查找</code>。</p>
<h5 id="变量环境组件与词法环境组件"><a href="#变量环境组件与词法环境组件" class="headerlink" title="变量环境组件与词法环境组件"></a>变量环境组件与词法环境组件</h5><blockquote>
<p>执行环境的词法环境和变量环境组件始终为 词法环境对象。</p>
</blockquote>
<p>  <strong>区别是：</strong><br>   ==let、const声明的变量，外部环境引用保存在词法环境组件中==。<br>   ==var和function声明的变量和保存在环境变量组件中。==</p>
<ul>
<li><p><strong>词法环境</strong>是一个用于定义特定变量和函数标识符在ECMAScript代码的词法嵌套结构上关联关系的规范类型。一个词法环境由一个<strong>环境记录项</strong>和可能为空的<strong>外部词法环境引用</strong>构成。 </p>
</li>
<li><p>Lexical Environments（词法环境）和四个类型的代码结构相对应:</p>
<ul>
<li>Global code:通俗点讲就是源文件代码，就是一个词法环境</li>
<li>==函数代码 ：一个函数块内自己是一个新的词法环境==</li>
<li>eval：进入eval调用的代码有时会创建一个新的词法环境</li>
<li>with结构：一个with结构块内也是自己一个词法环境</li>
<li>catch结构：一个catch结构快内也是自己一个词环境</li>
</ul>
</li>
</ul>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1585070616610&di=bfcafd31e88b7090537d6b2fc5b1144a&imgtype=0&src=http%3A%2F%2Fimg.shangdixinxi.com%2Fup%2Finfo%2F202001%2F20200106205413346203.png" alt="词法环境"></p>
<p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=255426644,1733497759&fm=15&gp=0.jpg" alt="执行上下文"></p>
<h1 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h1><ul>
<li><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3></li>
</ul>
<p>决定了一段代码能够访问到那些数据，这些数据存放在词法环境对象内。</p>
<ul>
<li><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3></li>
</ul>
<p><code>当执行一个函数时</code>，引擎会将函数的执行环境<code>推入执行栈</code>并<code>生成作用域链</code>。</p>
<p> 作用域链是一个==只能单向访问的链表==，这个链表上的每个节点就是<code>执行上下文的变量对象(代码执行时就是活动对象)</code>，单向链表的头部(可被第一个访问的节点)始终都是当前正在被调用执行的函数的变量对象(活动对象)，尾部始终是全局活动对象。 </p>
<p><img src="https://images2015.cnblogs.com/blog/1061765/201703/1061765-20170320120331315-901381700.png" alt="作用域链"></p>
<p>==作用域链的顶部永远是当前环境的词法环境对象，==下一个词法环境对象来自于包含环境，下下个词法环境对象来自于包含环境的包含环境。==作用域链的尾部是全局词法环境对象。==</p>
<p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3723626544,1683564314&fm=26&gp=0.jpg" alt="关于作用域链"></p>
<p>当我们在一个函数内部调用某一个变量时，会从<code>作用域链顶部</code>开始查找。如果在当前执行环境内存在定义则返回，否则会在<code>当前环境的词法环境组件中引用的外部环境引用中</code>查找。然后重复前面的逻辑，==直到找到全局词法环境对象（外部引用环境为null）==如果仍然未找到会抛出异常。</p>
<p><img src="https://img-blog.csdn.net/20160819161953835" alt="某一函数执行时的作用域链"></p>
<ul>
<li><p><strong>作用域链的用途是:</strong></p>
<p><strong>保证对执行环境有权访问的所有变量和函数的==有序==访问。</strong> </p>
</li>
</ul>
<h1 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h1><ul>
<li><p>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</p>
<p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2019533822,4075494923&fm=26&gp=0.jpg" alt="词法作用域"></p>
</li>
</ul>
<h1 id="块级作用域中的变量查找"><a href="#块级作用域中的变量查找" class="headerlink" title="块级作用域中的变量查找"></a>块级作用域中的变量查找</h1><ul>
<li>如果使用了一个在当前作用域中不存在的变量，这时 JavaScript 引擎就需要按照作用域链在其他作用域中查找该变量， </li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/24/JS%E8%BF%9B%E9%98%B61.5/" data-id="ck85ztlht00001kvffqfs42l3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS进阶1.4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/24/JS%E8%BF%9B%E9%98%B61.4/" class="article-date">
  <time datetime="2020-03-24T02:59:38.847Z" itemprop="datePublished">2020-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/24/JS%E8%BF%9B%E9%98%B61.4/">JS进阶1.4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JS中变量的作用域"><a href="#JS中变量的作用域" class="headerlink" title="JS中变量的作用域"></a>JS中变量的作用域</h1><ul>
<li><p>作用域：</p>
<p>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。</p>
</li>
</ul>
<p>1.在js中，变量的定义并<strong>不是以代码块作为作用域</strong>的，而是<strong>以==函数==作为作用域</strong>。也就是说，如果变量是在某个函数中定义的，那么，它在函数以外的地方是不可见的。<code>但是，如果该变量是定义在if或者for这样的代码块中，它在代码块之外是可见的。</code></p>
<p>2.在js中，术语“<strong>全局变量</strong>”指的是==定义在所有函数之外==的变量（也就是定义在全局代码中的变量），与之相对的是“<strong>局部变量</strong>”，所指的是==在某个函数中定义的==变量。其中，<code>函数内的代码可以像访问自己的局部变量那样访问全局变量，反之则不行。</code></p>
<h1 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h1><ul>
<li>JS中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称ES6)中新增了块级作用域。<br>==块作用域由 { } 包括==，if语句和for语句里面的{ }也属于块作用域。 </li>
</ul>
<h1 id="var、let、const的区别"><a href="#var、let、const的区别" class="headerlink" title="var、let、const的区别"></a>var、let、const的区别</h1><ul>
<li><p>变量提升（<strong>Hoisting</strong>），简单定义</p>
<p><strong>变量提升： 在指定作用域里，从代码顺序上看是变量先使用后声明，但运行时变量的 “可访问性” 提升到当前作用域的顶部，其值为 undefined ，没有 “可用性”。</strong></p>
</li>
</ul>
<ol>
<li><p>var定义的变量，没有块的概念，可以跨块访问, ==不能跨函数访问==， 有变量提升。 </p>
</li>
<li><p>let定义的变量，==只能在块作用域里访问==，不能跨块访问，也不能跨函数访问，无变量提升，不可以重复声明。 </p>
<p>在let声明变量前，使用该变量，它是会报错的，而不是像var那样会‘变量提升’。 ES6规定了在let声明变量前不能使用该变量。</p>
<p><strong>注意</strong>：实际上，let是提升了的，只是规定了不能在其声明之前使用而已。这一特性叫“暂时性死区”。且这一特性，仅对遵循‘块级作用域’的命令有效（let、const）。 </p>
</li>
<li><p>const用来定义常量，使用时==必须初始化==(即必须赋值)，==只能在块作用域里访问==，而且==不能修改==， 无变量提升，不可以重复声明。</p>
<p><strong>注意</strong>：const常量，指的是常量对应的内存地址不得改变，而不是对应的值不得改变，所有把应用类型的数据设置为常量，其内部的值是可以改变的，例如：const a={}; a.b=13;//不会报错 const arr=[]; arr.push(123);//不会报错 ； const 与 let 的使用规范一样，与之不同的是：const 声明的是一个常量，且这个常量必须赋值，否则会报错。 </p>
</li>
<li><p>同一个变量只能使用一种方式声明，不然会报错</p>
</li>
</ol>
<h1 id="变量提升所带来的问题"><a href="#变量提升所带来的问题" class="headerlink" title="变量提升所带来的问题"></a>变量提升所带来的问题</h1><h4 id="1-变量容易在不被察觉的情况下被覆盖掉"><a href="#1-变量容易在不被察觉的情况下被覆盖掉" class="headerlink" title="1. 变量容易在不被察觉的情况下被覆盖掉"></a>1. 变量容易在不被察觉的情况下被覆盖掉</h4><h4 id="2-本应销毁的变量没有被销毁"><a href="#2-本应销毁的变量没有被销毁" class="headerlink" title="2. 本应销毁的变量没有被销毁"></a>2. 本应销毁的变量没有被销毁</h4><h1 id="ES6是如何解决变量提升带来的缺陷"><a href="#ES6是如何解决变量提升带来的缺陷" class="headerlink" title="ES6是如何解决变量提升带来的缺陷"></a>ES6是如何解决变量提升带来的缺陷</h1><ul>
<li>ES6引入了let和const关键字，从而使JavaScript也能像其他语言一样拥有了块级作用域</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/24/JS%E8%BF%9B%E9%98%B61.4/" data-id="ck85ztli700011kvf402y3y1p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS进阶1.3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/23/JS%E8%BF%9B%E9%98%B61.3/" class="article-date">
  <time datetime="2020-03-23T10:29:05.442Z" itemprop="datePublished">2020-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/23/JS%E8%BF%9B%E9%98%B61.3/">JS进阶1.3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是JavaScript的调用栈"><a href="#什么是JavaScript的调用栈" class="headerlink" title="什么是JavaScript的调用栈"></a>什么是JavaScript的调用栈</h1><ul>
<li>JavaScript引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript引擎会将执行上下文压入栈中，通常把这种用来<strong>管理执行上下文的栈</strong>称为执行上下文栈，又称==调用栈==。</li>
<li>调用栈就是JS引擎追踪函数执行的一个机制</li>
</ul>
<h1 id="在开发中，如何利用好调用栈"><a href="#在开发中，如何利用好调用栈" class="headerlink" title="在开发中，如何利用好调用栈"></a>在开发中，如何利用好调用栈</h1><ul>
<li><p>如何利用浏览器查看调用栈的信息：</p>
<p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3091621571,2227256708&fm=15&gp=0.jpg" alt="在浏览器中查看调用栈"></p>
</li>
<li><p>使用 consol.trace() 来输出当前的函数调用关系 ：</p>
<p><img src="https://img2018.cnblogs.com/blog/945149/202001/945149-20200103195810005-1761393826.png" alt="trace"></p>
</li>
</ul>
<h1 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h1><img src="http://img3.mukewang.com/5b1278f50001286408000506.jpg" alt="栈溢出" style="zoom:80%;" />

<h3 id="stack-overflow常见解决方法"><a href="#stack-overflow常见解决方法" class="headerlink" title="stack overflow常见解决方法"></a>stack overflow常见解决方法</h3><p>stack overflow一般都是堆栈内存不够<br>1.<strong>递归次数过多</strong><br>解决办法：用==循环==来代替递归一般百分之九十能解决堆栈溢出的问题</p>
<p>2.<strong>创建的局部变量过多</strong><br>解决办法：这种情况一般就是因为局部变量没有及时清除导致的，一般也是递归，要么==把局部变量改成全局变量==，要么==传入引用==（就是再数据类型的前面加以个&amp;，这样不用去重新再子函数里面去开辟一个空间给变量了）要么==用指针==</p>
<p>3.<strong>数组开的过大</strong><br>解决办法：用 ==关键字 new 来动态的分配一个空间给数据==<br>例如： int a = new int[20000]，这样也可以一定程度的解决问题<br>这种方法也可以提高运行速度，但是会牺牲一些内存：</p>
<h3 id="Windows程序的内存机制"><a href="#Windows程序的内存机制" class="headerlink" title="Windows程序的内存机制"></a>Windows程序的内存机制</h3><p>全局变量(局部的静态变量本质也属于此范围)存储于<strong>堆内存,该段内存较大,一般不会溢出</strong>;函数地址、函数参数、局部变量等信息存储于栈内存，<strong>栈内存较小容易发生溢出现象，但是效率高。</strong> </p>
<h3 id="栈溢出的可能原因："><a href="#栈溢出的可能原因：" class="headerlink" title="栈溢出的可能原因："></a><strong>栈溢出的可能原因：</strong></h3><p><strong>1. 函数递归调用层次过深</strong> ，每调用一次，函数的参数、局部变量等信息就压一次栈，并且没有及时出栈。<br><strong>2. 局部变量体积太大</strong> </p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a><strong>解决方案：</strong></h3><p><strong>1.把递归调用函数改用while或者for==循环==来实现</strong> 。<br><strong>2.通过==尾递归优化==</strong>。<br><strong>3.==改用堆内存==</strong>，函数里定义很大的局部变量（例如大数组），这种情况可以将局部变量改为静态变量（实质上也是全局变量）。<br><strong>4.==增大栈的大小值==</strong>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>每调用一个函数。JavaScript引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后JavaScript引擎开始执行函数代码</li>
<li>如果在一个函数A中调用了另一个函数B，那么JavaScript引擎会为B函数创建执行上下文，并将B函数的执行上下文压入栈顶</li>
<li>当前函数执行完毕后，JavaScript引擎会将该函数的执行上下文弹出栈</li>
<li>当分配的调用栈空间被占满时，会引发”堆栈溢出”问题</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/23/JS%E8%BF%9B%E9%98%B61.3/" data-id="ck85a9jih0000f4vfd46fft1d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS进阶1.2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/23/JS%E8%BF%9B%E9%98%B61.2/" class="article-date">
  <time datetime="2020-03-23T01:58:56.660Z" itemprop="datePublished">2020-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/23/JS%E8%BF%9B%E9%98%B61.2/">JS进阶1.2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><ul>
<li><p>可以将“执行上下文”看做当前代码的运行环境或者作用域 </p>
<p>( JS代码被解析和运行时所处的环境，被称之为JavaScript中的执行上下文 )</p>
</li>
</ul>
<img src="https://segmentfault.com/img/remote/1460000008315046" alt="执行上下文" style="zoom:80%;" />

<p>==在执行上下文创建阶段，函数声明与var声明的变量在创建阶段已经被赋予了一个值，var声明被设置为了undefined，函数被设置为了自身函数==，而let const被设置为未初始化 </p>
<ul>
<li><p>JavaScript中的执行上下文分为以下三种类型：全局执行上下文、函数执行上下文、Eval函数执行上下文。 </p>
<ol>
<li><p><strong>全局执行上下文</strong> </p>
<p>在JavaScript中式默认以及最基本的执行上下文，范围很大，类似于全局作用域，当目标代码不在任何函数中的时候，它就位于全局执行上下文中，处于全局执行上下文中的代码做了两件事儿：</p>
<p>1&gt;创建一个全局对象，例如浏览器中的全局对象就是window对象；</p>
<p>2&gt;将this指向这个全局对象，而且需要注意的是：一个程序代码中只存在有且只有一个全局执行上下文；</p>
</li>
<li><p><strong>函数执行上下文</strong> </p>
<p>函数执行上下文，就是处于函数体内的代码解析及运行的环境，当每次调用函数的时候，都会给该函数创建一个函数执行上下文，虽然每个函数都有自己的函数执行上下文，但是只有当函数<code>被调用时</code>该函数执行上下文才会被创建。既然是函数，所以在一个代码程序中可以存在多个函数执行上下文。</p>
</li>
</ol>
</li>
<li><p>当进入每一个函数时，执行该函数就会创建一个函数执行上下文，依次将其推入执行栈的顶部，当<code>函数全部执行完毕</code>，当前函数就开始执行上下文出栈操作，等待垃圾回收</p>
</li>
<li><p>执行上下文栈的特点：</p>
<ol>
<li><p>JS引擎总是从栈顶向下访问</p>
</li>
<li><p>同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待</p>
</li>
<li><p>全局上下文有且仅有一个，并且在<code>浏览器关闭时</code>执行出栈操作</p>
</li>
</ol>
</li>
</ul>
<h1 id="编译器预编译与变量提升"><a href="#编译器预编译与变量提升" class="headerlink" title="编译器预编译与变量提升"></a>编译器预编译与变量提升</h1><ul>
<li><p><strong>编译器解析规则</strong></p>
<p> 编译器运行代码，分为2个阶段，一个预编译阶段，一个是运行阶段 </p>
</li>
<li><p><strong>变量提升</strong></p>
<p>var a = 2这个表达式，实际上javascript将其分为2个声明，var a 和 a = 2；</p>
<p>第一个定义声明在编译阶段，第二个赋值声明在运行阶段；</p>
<p> 这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动” 到了最上面。这个过程就叫作<code>提升</code>。 </p>
</li>
<li><p><strong>函数提升</strong></p>
<p> 函数声明会进行，函数提升，但是函数表达式并不会进行函数提升 </p>
</li>
<li><p>函数优先</p>
<p> 当有变量声明和函数声明的变量名称相同时，根据函数优先原则，函数会覆盖变量； </p>
</li>
</ul>
<img src="https://img-blog.csdnimg.cn/20190925111208117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTg1NTEx,size_16,color_FFFFFF,t_70" alt="此类情况应避免" style="zoom:80%;" />

<ul>
<li><p>summary</p>
<p>1、js代码的运行会分为2个步骤，预编译和运行（执行）阶段，预编译看下面的总结，执行就是从上往下一行一行的运行；</p>
<p>2、找文中的var 和 function；将var的变量和function声明的变量提升到顶部，var的初始化为undefined，function的初始化为函数。</p>
<p>3、var的变量和函数的变量名称相同的时候，根据函数优先的原则，函数会覆盖之前var变量； </p>
<p>4、<strong>var相同的名称，后续声明会忽略；function相同的名称，后续声明会覆盖</strong>；</p>
<p>5、函数定义var foo = function(){} 就当 变量来处理；也就是文中所说的函数声明会提升，但是函数表达式不会提升</p>
</li>
</ul>
<p>==函数声明会整体提升，变量声明仅声明提升（赋值不提升）==</p>
<h1 id="变量对象与预解析"><a href="#变量对象与预解析" class="headerlink" title="变量对象与预解析"></a>变量对象与预解析</h1><p><img src="https://image-static.segmentfault.com/166/721/1667217985-5a168ff4377d9_articlex" alt="执行环境（执行上下文）"></p>
<h3 id="变量对象的创建过程"><a href="#变量对象的创建过程" class="headerlink" title="变量对象的创建过程"></a>变量对象的创建过程</h3><p>1.<strong>建立一个argunments对象</strong>，寻找当前上下文中的参数，并以其参数名以及参数值创建一个属性。</p>
<p>2.<strong>寻找当前上下文当中的function声明</strong>，在变量对象中，以函数名为属性名，创建一个属性，值为函数的引用地址，如果函数名重复的话，后面的引用会覆盖前面的</p>
<p>3.<strong>寻找当前上下文当中的var声明</strong>，在变量对象中，以变量名为其属性名，创建以个属性，值为undefined， <strong>如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。</strong> </p>
<p><img src="https://image-static.segmentfault.com/375/950/37595014-5a16900337e4f_articlex" alt="变量对象的创建过程"></p>
<p>==function声明会比var声明优先级更高一点==</p>
<ul>
<li>变量对象实例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(foo());</span><br><span class="line">  <span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>当执行到test()时会生成执行环境 testEC ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建过程</span></span><br><span class="line">testEC=&#123;</span><br><span class="line">  <span class="comment">//变量对象（variable object）</span></span><br><span class="line">  VO:&#123;&#125;,</span><br><span class="line">  <span class="comment">//作用域链</span></span><br><span class="line">  scopeChain：[],</span><br><span class="line">  <span class="comment">//this指向</span></span><br><span class="line">  <span class="keyword">this</span>：&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对变量对象展开：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">VO=&#123;</span><br><span class="line">  <span class="comment">//传参对象</span></span><br><span class="line">  <span class="built_in">arguments</span>：&#123;&#125;,</span><br><span class="line">  <span class="comment">//在testEC中定义的function</span></span><br><span class="line">  foo:<span class="string">"&lt;foo reference&gt;"</span>,</span><br><span class="line">  <span class="comment">//在testEC中定义的var</span></span><br><span class="line">  a:<span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作</strong> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行阶段</span></span><br><span class="line">VO-&gt;AO<span class="comment">//Active Object</span></span><br><span class="line">AO=&#123;</span><br><span class="line">  <span class="built_in">arguments</span>:&#123;...&#125;,</span><br><span class="line">  foo:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">2</span>&#125;,</span><br><span class="line">  a:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 最后我们将变量对象创建时的VO和执行阶段的AO整合到一起就可以得到整个执行环境中代码的执行顺序： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span>  <span class="title">foo</span>(<span class="params"></span>)//函数声明整体提升</span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line">  <span class="keyword">var</span> a;<span class="comment">//变量声明仅声明提升</span></span><br><span class="line">  <span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(foo());<span class="comment">//2</span></span><br><span class="line">  a=<span class="number">1</span>;<span class="comment">//赋值不提升</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代码中出现相同的变量或者函数怎么办"><a href="#代码中出现相同的变量或者函数怎么办" class="headerlink" title="代码中出现相同的变量或者函数怎么办"></a>代码中出现相同的变量或者函数怎么办</h1><ul>
<li>实例：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showname</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"SIPC"</span>);</span><br><span class="line">&#125;</span><br><span class="line">showname();<span class="comment">//115</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showname</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"115"</span>);</span><br><span class="line">&#125;</span><br><span class="line">showname();<span class="comment">//115</span></span><br></pre></td></tr></table></figure>

<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p><strong>编译时：</strong></p>
<ul>
<li>遇到第一个showname函数，会将其函数体存放到变量环境中</li>
<li>then 遇到第二个showname函数，会继续存放，但<code>2会将1覆盖掉</code></li>
<li>end 变量环境中就只存在第二个showname函数</li>
</ul>
<p><strong>执行时</strong>：</p>
<ul>
<li>由于是从变量环境中查找的showname函数，而变量环境中只保存了第二个showname函数，所以最终，两次调用的都是第二个showname函数的函数体，都打印出115</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>JavaScript代码执行过程中，需要先做变量提升，而之所以需要实现变量提升，是因为JavaScript代码在执行之前需要先编译。在编译阶段，变量和函数会<strong>被存放到变量环境中</strong>，变量的默认值会被设置为undefined；</li>
<li>在代码执行阶段，JavaScript引擎会从<strong>变量环境中</strong>去查找自定义的变量和函数。</li>
<li>如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，这是因为后定义的会<strong>覆盖掉</strong>之前定义的。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/23/JS%E8%BF%9B%E9%98%B61.2/" data-id="ck84bqon50000pgvfdhesdyqp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS进阶1.1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/22/JS%E8%BF%9B%E9%98%B61.1/" class="article-date">
  <time datetime="2020-03-22T15:10:00.570Z" itemprop="datePublished">2020-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/22/JS%E8%BF%9B%E9%98%B61.1/">JS进阶1.1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##JS进阶1.1<br>###数据是如何存储的？</p>
<ul>
<li><strong>基本数据结构</strong>：</li>
</ul>
<p>1.栈：先进后出，后进先出，存一些基本数据类型（即简单的数据段）和引用数据类型的地址<br><img src="http://images.cnitblog.com/i/627148/201405/021619565332359.png" alt="栈"><br>2.堆：无序储存，随用随取（可以通过引用直接获取）的一个空间（不关注存放的顺序，需通过栈内存中存放的地址来访问堆内存中对应的值），空间比较大，存储一些引用数据类型（占据空间大，大小不固定）<br><img src="https://bkimg.cdn.bcebos.com/pic/574e9258d109b3de15adc33ec7bf6c81800a4c51?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U5Mg==,xp_5,yp_5" alt="堆"><br><font color="grey" size="2">堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。</font><br><img src="https://img-blog.csdn.net/20180109104006090?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm1pbmVt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="栈与堆"><br>#####复制<br>######基本数据类型<br>对于基本数据类型，如果进行复制，系统会自动为新的变量在栈内存中分配一个新值</p>
<p>######引用数据类型<br>如果对于数组、对象这样的引用数据类型而言，<br>系统也会自动为新的变量在栈内存中分配一个值，但这个值仅仅是一个地址。<br>也就是说，复制出来的变量和原有的变量具有相同的地址值，指向堆内存中的同一个对象。<br><img src="https://img-blog.csdn.net/20180109104235195?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm1pbmVt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="关于复制"><br><font color="grey" size="2">当修改 obj 或 objCopy 时，都会引起另一个变量的改变。</font><br>3.队列:先进先出<br><img src="http://aliyunzixunbucket.oss-cn-beijing.aliyuncs.com/jpg/06735aeceb8425df63025f26921094ec.jpg?x-oss-process=image/resize,p_100/auto-orient,1/quality,q_90/format,jpg/watermark,image_eXVuY2VzaGk=,t_100" alt="队列"></p>
<ul>
<li><strong>内存空间</strong></li>
</ul>
<p>1.代码空间<br>2.栈空间<br>3.堆空间</p>
<ul>
<li><strong>基本数据类型</strong>:</li>
</ul>
<p>1.Boolean:只有true和false两个值<br>2.Null：只有一个值null<br>3.Undefined：一个没有被赋值的变量默认值为undefined，变量提升时的默认值也是undefined<br>4.Number<br>5.BigInt：可以用任意精度表示整数<br>6.String<br>7.Symbol：符号类型唯一的并且是不可修改的，通常用来作Object的key</p>
<ul>
<li><strong>引用数据类型</strong></li>
</ul>
<p>1.Array<br>2.Object</p>
<p>###静态语言、动态语言、强类型语言、弱类型语言</p>
<ul>
<li><strong>静态语言</strong>：<br><strong>编译时</strong>变量的数据类型即可确定，多数静态语言要求在使用变量之前必须声明数据类型<br>变量若不经强制转换，则永远是该指定的数据类型<br>结构规范，便于调试，较安全，严谨</li>
<li><strong>强类型语言</strong>：不支持隐式类型转换</li>
<li><strong>动态语言</strong>：<br><strong>运行时</strong>确定数据类型，变量的类型是被赋值的那个值的类型，使用之前不需要类型声明<br>一个变量可以赋不同数据类型的值，一个变量的类型是由其应用上下文确定的<br>数据类型可以被忽略，速度快</li>
<li><strong>弱类型语言</strong>：支持隐式类型转换<br><font color="grey">JavaScript是一种动态弱类型语言</font></li>
</ul>
<p>###js中的隐式类型转换<br>Javascript 中，数字 0 为假，非0 均为真</p>
<p>####在条件判断运算 == 中的转换规则是这样的:</p>
<ul>
<li><p>如果比较的两者中有布尔值(Boolean)，会把 Boolean 先转换为对应的 Number，即 0 和 1，然后进行比较。</p>
</li>
<li><p>如果比较的双方中有一方为 Number，一方为 String时，会把 String 通过 Number() 方法转换为数字，然后进行比较。</p>
</li>
<li><p>如果比较的双方中有一方为 Boolean，一方为 String时，则会将<strong>空字符串</strong>“”转换为 false，除此外的一切字符串转换为 true，然后进行比较。</p>
</li>
<li><p>如果比较的双方中有一方为 Number，一方为Object时，则会调用 <strong>valueOf 方法</strong>将Object转换为数字，然后进行比较。</p>
<p>建议在所有使用<strong>条件判断</strong>的时候都使用<strong>全等运算符 ===</strong> 来进行条件判断。全等运算符会先进行数据类型判断，并且<strong>不会发生隐式类型转换</strong>。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/22/JS%E8%BF%9B%E9%98%B61.1/" data-id="ck836lj1b00007kvfbmfg0dh0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-first blog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/21/first%20blog/" class="article-date">
  <time datetime="2020-03-21T14:49:43.691Z" itemprop="datePublished">2020-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/21/first%20blog/">First Blog</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###Jenn’s Blog</p>
<blockquote>
<p>满地都是六便士，他却抬头看见了月亮。        ——《月亮和六便士》</p>
</blockquote>
<p>Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p>
<p>由于Markdown的轻量化、易读易写特性，并且对于图片、图表、数学式都有支持，被网站广泛使用来撰写帮助文档或是用于论坛上发表消息。<br>写一个列表</p>
<ul>
<li>无序列表</li>
<li>无序列表<br>再写一个有序列表</li>
</ul>
<ol>
<li>有序列表</li>
<li>有序列表</li>
</ol>
<p><img src="https://wx3.sinaimg.cn/mw1024/007iocwWly1fzodvqswysj30px122djp" alt="雷姆"></p>
<p>超链接<br><a href="https://123.sogou.com/?121172" target="_blank" rel="noopener">baidu</a><br><strong>文字加粗</strong><br><em>斜体</em></p>
<center><font face="微软雅黑" color="pink" size="28" >修改字体颜色和字号</font></center>






      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/21/first%20blog/" data-id="ck81qei5g0000zovf7i0d4uni" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/21/hello-world/" class="article-date">
  <time datetime="2020-03-21T03:09:15.274Z" itemprop="datePublished">2020-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/21/hello-world/">Hello Jenn</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/21/hello-world/" data-id="ck812kxmp00003cvfgl9qgme3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/24/JS%E8%BF%9B%E9%98%B61.5/">JS进阶1.5</a>
          </li>
        
          <li>
            <a href="/2020/03/24/JS%E8%BF%9B%E9%98%B61.4/">JS进阶1.4</a>
          </li>
        
          <li>
            <a href="/2020/03/23/JS%E8%BF%9B%E9%98%B61.3/">JS进阶1.3</a>
          </li>
        
          <li>
            <a href="/2020/03/23/JS%E8%BF%9B%E9%98%B61.2/">JS进阶1.2</a>
          </li>
        
          <li>
            <a href="/2020/03/22/JS%E8%BF%9B%E9%98%B61.1/">JS进阶1.1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>